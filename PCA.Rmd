---
title: "PCA"
author: "Matt Nolan"
date: "02/05/2018"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Ensure access to libraries
library(tidyverse)
library (pls)
library(GGally)
```

## Goals

To reduce the dimensionality of the dataset. To explore how dorsoventral location and mouse identity map onto each dimension. To evaluate linear models generated using the principal components.

Carry out PCA.
```{r}
data.pca <- dplyr::select(data.sc, vm:fi, dvlocmm, id)
cols.pca <- 1:11

out.pca <- prcomp(data.pca[cols.pca],
                  retx = TRUE,
                  centre = TRUE,
                  scale = TRUE)

plot(out.pca)
summary(out.pca)
biplot(out.pca)
```



Plot components vs dosrosventral location. Colour code mouse ID.
```{r}
out.pca.x <- as_tibble(out.pca$x)
out.pca.x$dvlocmm <- data.pca$dvlocmm
out.pca.x$id <- data.pca$id

out.pca.x <- out.pca.x %>%
  gather("component", "value", 1:11)

ggplot(data = out.pca.x, aes(x = dvlocmm, y = value)) +
  geom_point(aes(colour = id)) +
  facet_wrap(~ component)
```


Plot components seperately for each mouse.
```{r}
ggplot(data = out.pca.x, aes(x = id, y = value)) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~ component, scales = "free_x")
```

Plot components against one another.
```{r}
out.pca.x_2 <- as_tibble(out.pca$x)
out.pca.x_2$dvlocmm <- data.pca$dvlocmm
out.pca.x_2$id <- data.pca$id
ggpairs(out.pca.x_2,columns = c(1:4), ggplot2::aes(colour=id, alpha = 0.1))
```


Reform data for use with dplyr.
```{r}
out.pca.x_g <- group_by(out.pca.x, component) %>%
  nest()
```

Fit mixed model for each principal component as a function of dorsoventral position.
```{r}
model_to_fit_PCA <- function(df) {
  lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
out.pca.x_g <- out.pca.x_g %>%
  mutate(mixedmodel = map(data, model_to_fit_PCA))
```


Add model predictions. Using predict adds a prediction for each location, using broom::augment adds predictions (.mu) and residuals (.wtres).
```{r}
out.pca.x_g <- out.pca.x_g %>%
  mutate(fit = map(mixedmodel, predict))

out.pca.x_g <- out.pca.x_g %>%
  mutate(fits = map(mixedmodel, broom::augment))
```


Add summaries of model output
```{r}
out.pca.x_g <- out.pca.x_g %>%
  mutate(tidy = map(mixedmodel, broom::tidy))
```

Extract coefficients for individual mice. The function is to convert the output of coef() to a dataframe so it will work with unnest.
```{r}
coef_df_PCA <- function(model_name) {
  mod_coef <- coef(model_name)
  tibble(id = row.names(mod_coef[[1]]), intercept = mod_coef[[1]][[1]], slope = mod_coef[[1]][[2]])
}
out.pca.x_g <- out.pca.x_g %>%
  mutate(coefs = map(mixedmodel, coef_df_PCA))
```

Convert data from the nested format so that we can make plots of the fitted data.
```{r}
out.pca.x_g_fit <- out.pca.x_g %>%
  unnest(data, fit)
```

Make plots
```{r}
ggplot(out.pca.x_g_fit, aes(x = dvlocmm, y = value)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~component, scales = "free")
```



Extract individual slopes and intercepts from model fits.
```{r}
out.pca.x_g_coefs <- out.pca.x_g %>%
  unnest(coefs)
```


Add slope to intercept to predict values at 1 mm for each mouse.
```{r}
out.pca.x_g_coefs$is <- out.pca.x_g_coefs$intercept + out.pca.x_g_coefs$slope
```

To enable plotting of slopes on the same graph, but seperately from the intercepts, make columns containing population intercepts, and population intercept + slope for each mouse.
```{r}
pop_intercepts_PCA <- unnest(out.pca.x_g, tidy) %>% filter(term == "(Intercept)") %>% dplyr::select(component, estimate)
out.pca.x_g_coefs_regather <- out.pca.x_g_coefs %>%
  dplyr::select(component, id, slope) %>%
  spread(key = id, value = slope) %>%
  left_join(pop_intercepts_PCA, by = "component") %>%
  gather("id", "slope", -estimate, -component) %>%
  mutate(intercept_slope = estimate + slope) %>%
  dplyr::select(component, id, estimate, intercept_slope) %>%
  gather(measure, value, estimate, intercept_slope)
```



Plot predicted values at 0 mm and at 1mm for each mouse.
```{r}
out.pca.x_g_coefs_01 <- out.pca.x_g_coefs %>%
  dplyr::select(id, component, intercept, is) %>%
  gather(measure, value, intercept, is)
intercept_slope_plot_a <- ggplot(out.pca.x_g_coefs_01, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~component, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_b <- ggplot(out.pca.x_g_coefs_01, aes(x = measure, y = value)) +
  geom_jitter(width = 0.2, height = 0) +
  facet_wrap(~component, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_a
intercept_slope_plot_b
```

Combine plots of intercept and slopes. Need to combine out.pca.x_g_coefs_01 and out.pca.x_g_coefs_regather and add housing. Make property into factors to enable ordering of plots. Then make appropriately faceted plots.

```{r}
out.pca.x_g_coefs_regather <- mutate(out.pca.x_g_coefs_regather, value_1 = value)
out.pca.x_g_coefs_01 <- mutate(out.pca.x_g_coefs_01, value_2 = value)
combined_intercepts_slopes_PCA <- bind_rows(out.pca.x_g_coefs_regather, out.pca.x_g_coefs_01)

#id_housing <-  distinct(out.pca.x, id, housing)
#combined_intercepts_slopes_PCA <- left_join(combined_intercepts_slopes_PCA, id_housing, by = "id")

combined_intercepts_slopes_PCA$component_factors <- as.factor(combined_intercepts_slopes_PCA$component)
combined_intercepts_slopes_PCA$component_factors = factor(combined_intercepts_slopes_PCA$component_factors, c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11"))

IS_figure_PCA <- ggplot(combined_intercepts_slopes_PCA, aes(x = measure, y = value_1)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("intercept", "is",  "estimate", "intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~component_factors) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure_PCA
```




A slightly different approach, directly fitting model to PCR output.
```{r}
data.pca <- dplyr::select(data.sc.norm, vm:ahp, dvlocmm)
pcr.fit=pcr(dvlocmm~., data=data.pca,scale=TRUE , validation ="CV")
summary(pcr.fit)
```

Evaluate mean squared error of prediction
```{r}
validationplot(pcr.fit ,val.type="MSEP")
```
