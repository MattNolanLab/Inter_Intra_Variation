---
title: "Functions"
author: "Matt Nolan"
date: "17/05/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggthemes)
```

Goals: functions for mixed model and related analysis of multiple electrophysiological properties. Functions are removed from individual .Rmd documents so they can be re-used in multiple analyses.

----------------------- Models ------------------------

# Model vs random intercept and slope. Use this model for all main analyses (see Barr et al. Journal of Memory and Language, 2013)
model_to_fit 




```{r}
model_to_fit <- function(df) {
  lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
```

- used in Interanimal.rmd
- used in PCA.rmd




   
```{r}
## Model for random intercept and slope
model_vsris <- function(df) {
    lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}

## Null model for random intercept and slope
model_vsris_null <- function(df) {
    lme4::lmer(value ~ 1+dvlocmm||id, data = df, REML = FALSE, na.action = na.exclude)
}

## Model vs random intercept.
model_vsri <- function(df) {
    lme4::lmer(value ~ dvlocmm +(1|id), data = df, REML = FALSE, na.action = na.exclude)
}
## Null model vs random intercept.
model_vsri_null <- function(df) {
    lme4::lmer(value ~ 1|id, data = df, REML = FALSE, na.action = na.exclude)
}
## Model vs correlated random intercept and slope.
model_vscris <- function(df) {
    lme4::lmer(value ~ dvlocmm +(1+dvlocmm|id), data = df, REML = FALSE, na.action = na.exclude)
}
## Null model vs correlated random intercept and slope.
model_vscris_null <- function(df) {
  lme4::lmer(value ~ 1+dvlocmm|id, data = df, REML = FALSE, na.action = na.exclude)
}
```

Bayesian linear mixed models using MCMCglmm
```{r}
## ------------------------------------------------------
## 
## ------------------------------------------------------

## codes risc
## r: random
## i: intercept
## s: slope
## c: correlated

## M1

## null model has only intercept in the fixed effects
model_vsri_null_McMC <- function(df) {
    ## dependent random intercept and random slope
    ## specification of prior distribution
    prior = list(B=list(mu=rep(0,1), V=diag(1e+8, 1)),
                 R = list(V = diag(1, 1), nu=0.001),
                 G = list(G1= list(V = diag(1,1), nu=0.001)))
    ## model fitting
    MCMCglmm::MCMCglmm(fixed  = value ~ 1,
                       random = ~ idh(1):id,
                       data   = as.data.frame(df),
                       family = "gaussian",
                       prior  = prior,
                       pr     = TRUE)
}
## 
model_vsri_McMC <- function(df) {
    ## dependent random intercept and random slope
    ## specification of prior distribution
    prior = list(B=list(mu=rep(0,2), V=diag(1e+8, 2)),
                 R = list(V = diag(1, 1), nu=0.001),
                 G = list(G1= list(V = diag(1,1), nu=0.001) ))
    ## model fitting
    MCMCglmm::MCMCglmm(fixed  = value ~ 1 + dvlocmm,
                       random = ~ idh(1):id,
                       data   = as.data.frame(df),
                       family = "gaussian",
                       prior  = prior,
                       pr     = TRUE)
}

## M2

## null model has intercept only in the fixed effects
model_vsris_null_McMC <- function(df) {
    ## independent random intercept and random slope
    ## specification of prior distribution
    prior = list(B=list(mu=rep(0,1), V=diag(1e+8, 1)),
                 R = list(V = diag(1, 1), nu=0.001),
                 G = list(G1= list(V = diag(1,2), nu=0.001) ))
    ## model fitting
    MCMCglmm::MCMCglmm(fixed  = value ~ 1,
                       random = ~ idh(1+dvlocmm):id,
                       data   = as.data.frame(df),
                       family = "gaussian",
                       prior  = prior,
                       pr=TRUE)
}
## 
model_vsris_McMC <- function(df) {
    ## independent random intercept and random slope
    ## specification of prior distribution
    prior = list(B=list(mu=rep(0,2), V=diag(1e+8, 2)),
                 R = list(V = diag(1, 1), nu=0.001),
                 G = list(G1= list(V = diag(1,2), nu=0.001) ))
    ## model fitting
    MCMCglmm::MCMCglmm(fixed  = value ~ 1 + dvlocmm,
                       random = ~ idh(1+dvlocmm):id,
                       data   = as.data.frame(df),
                       family = "gaussian",
                       prior  = prior,
                       pr=TRUE)
}

## M3

## null model has intercept only in the fixed effects
model_vsrisc_null_McMC <- function(df) {
    ## independent random intercept and random slope
    ## specification of prior distribution
    prior = list(B=list(mu=rep(0,1), V=diag(1e+8, 1)),
                 R = list(V = diag(1, 1), nu=0.001),
                 G = list(G1= list(V = diag(1,2), nu=0.001) ))
    ## model fitting
    MCMCglmm::MCMCglmm(fixed  = value ~ 1,
                       random = ~ us(1+dvlocmm):id,
                       data   = as.data.frame(df),
                       family = "gaussian",
                       prior  = prior,
                       pr=TRUE)
}
## 
model_vsrisc_McMC <- function(df) {
    ## independent random intercept and random slope
    ## specification of prior distribution
    prior = list(B=list(mu=rep(0,2), V=diag(1e+8, 2)),
                 R = list(V = diag(1, 1), nu=0.001),
                 G = list(G1= list(V = diag(1,2), nu=0.001) ))
    ## model fitting
    MCMCglmm::MCMCglmm(fixed  = value ~ 1 + dvlocmm,
                       random = ~ us(1+dvlocmm):id,
                       data   = as.data.frame(df),
                       family = "gaussian",
                       prior  = prior,
                       pr=TRUE)
}

```



Bayesian linear mixed models using rstanarm

```{r}

## null model has only intercept in the fixed effects
model_vsri_null_stan <- function(df, K=4) {
    rstanarm::stan_lmer(value ~ 1 + (1|id), data = df, cores=K)
}
## 
model_vsri_stan <- function(df, K=4) {
    ## dependent random intercept and random slope
    ## specification of prior distribution
    rstanarm::stan_lmer(value ~ 1+dvlocmm + (1|id), data = df, cores=K)
}

## M2
## null model has intercept only in the fixed effects
model_vsris_null_stan <- function(df, K=4) {
    ## independent random intercept and random slope
    ## specification of prior distribution
    ## model fitting
    rstanarm::stan_lmer(value ~ 1 + (1+dvlocmm||id), data = df, cores=K)
}
## 
model_vsris_stan <- function(df, K=4) {
    ## independent random intercept and random slope
    ## specification of prior distribution
   
    ## model fitting
    rstanarm::stan_lmer(value ~ 1 + dvlocmm + (1+dvlocmm||id), data = df, cores=K)
}


## M3
## M2
## null model has intercept only in the fixed effects
model_vsrisc_null_stan <- function(df, K=4) {
    ## independent random intercept and random slope
    ## specification of prior distribution
    ## model fitting
    rstanarm::stan_lmer(value ~ 1 + (1+dvlocmm|id), data = df, cores=K)
}
## 
model_vsrisc_stan <- function(df, K=4) {
    ## independent random intercept and random slope
    ## specification of prior distribution
   
    ## model fitting
    rstanarm::stan_lmer(value ~ 1 + dvlocmm + (1+dvlocmm|id), data = df, cores=K)
}
```


 
```{r}
linearmodel_to_fit <- function(df) {
  lm(value ~ dvlocmm, data = df, na.action = na.exclude)
}
```
- used in Interanimal.rmd
- used in PCA.rmd

Alternative way to fit mixed model using nlme for compatibility with ANOVA.
```{r}
# Gives error when random term incluces dvlocmm
nlmemodel_to_fit <- function(df) {
  nlme::lme(value ~ dvlocmm, random = ~1|id, data = df, method = "ML", na.action = na.exclude)
}
```


------------------ Helper functions ---------------------

Function to source Rmd files
```{r}
source_rmd <- function(file, local = FALSE, ...){
  options(knitr.duplicate.label = 'allow')
  ## --------------------------------------------
  tempR <- tempfile(tmpdir = ".", fileext = ".R")
  on.exit(unlink(tempR))
  knitr::purl(file, output=tempR, quiet = TRUE)
  ## --------------------------------------------
  envir <- globalenv()
  source(tempR, local = envir, ...)
}

```

Helper function to return model coefficients in a tidy format.
```{r}
coef_df <- function(model_name) {
  mod_coef <- coef(model_name)
  tibble(id = row.names(mod_coef[[1]]), intercept = mod_coef[[1]][[1]], slope = mod_coef[[1]][[2]])
}
```
- used in Internanimal.rmd
- used in PCA.rmd

Helper functions for chi-squared test to compare linear with mixed models.
```{r}
devcalc <- function(df){
  dev <- -2*logLik(df)
}

extractdf <- function(dev){
  attr(dev,"df")
}

# CAn this be improved? Returning a tibble / df seems a bit clunky.
mixed_vs_linear_pchisqu <- function(df){
    df <- df %>%
        mutate(dev_mixed = map(mixedmodel_vsris, devcalc)) %>%
        mutate(dev_linear = map(linearmodel, devcalc)) %>%
        mutate(devdiff = as.numeric(dev_linear) - as.numeric(dev_mixed)) %>%
        mutate(dev_mixed_df = map(dev_mixed, extractdf)) %>%
        mutate(dev_linear_df = map(dev_linear, extractdf)) %>%
        mutate(dfdiff = as.numeric(dev_mixed_df) - as.numeric(dev_linear_df)) %>%
        mutate(pdiff = pchisq(devdiff,dfdiff,lower.tail=FALSE))
    tibble(dev_mixed = df$dev_mixed,
           dev_linear = df$dev_linear,
           devdiff = df$devdiff,
           dev_mixed_df = df$dev_mixed_df,
           dev_linear_df = df$dev_linear_df,
           dfdiff = df$dfdiff,
           pdiff = df$pdiff)
}
```
- used in Internanmal.rmd
- used in PCA.rmd


Function for presentation of data.
```{r}
hist_theme = theme(
    text = element_text(size=9),
    strip.background = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank()
  )
```


Helper functions for manipulating MCMCglmm objects using tidyverse
```{r}


keep_rownames<- function(df, column.name="rname")
    ## store the rownames in new column when converting a data frame to tibble
{
    df %>%
        as.data.frame() %>%
        as_tibble() %>%
        rownames_to_column("rname")
}


HPD <- function(fittedmodel, type="sol")
    ## extract Highest Posterior Density intervals 
    ## for both fixed and random effects
    ## argument type: can take either "sol" or "vcov"
    ## sol yields intervals for betas (both fixed and random)
    ## vcov yields intervals for variances (and covariances if these
    ## (are specified in the model) of random effects and residuals     
{
    if(type=="sol")
        tmp <- HPDinterval(fittedmodel$Sol)
    if(type=="vcov")
        tmp <- HPDinterval(fittedmodel$VCV)
    ## 
    keep_rownames(tmp)
}


HPD_nonverbose<- function(HPDobject,
                         stringmatch="Intercept).id.mouse",
                         stringreplace="\\(Intercept\\)\\.id\\.mouse\\.")
    ## helper function to convert HPD objects to long format and extract
    ## betas from random effects. The function is a pre-step to a ggplot call.
    ## args stringmatch and stringreplace are tidying up the verbose names
    ## obtained from the MCMCglmm output
    ## stringmatch:
    ## 1. "Intercept).id.mouse", corresponds to random intercept -- default option
    ## 2. "dvlocmm.id.mouse", corresponds to random slope
    ## stringreplace:
    ## 1.  "\\(Intercept\\)\\.id\\." -- default option
    ## 2. "dvlocmm\\.id\\."
{   
    ## TODO add a stopifnot statement for consistency in use of arguments
    ## stringmatch and stringreplace
    df_long <- gather(HPDobject, HPDendpoint, value, -rname) 
    df_long <- df_long%>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
        mutate(mouse.id=gsub(pattern=stringreplace,
                             replacement="", rname)) %>%
        dplyr::select(-rname)
    df_wide <- spread(df_long, HPDendpoint, value)
    return(df_wide)
}

ggplotHPD <- function(df, yLab="Intercept")
{
    p <- ggplot(df) +
        geom_point(aes(x=reorder(mouse.id, -lower),
                       y=value)) +
        geom_errorbar(aes(x=mouse.id, ymin=lower, ymax=upper)) + 
        geom_hline(yintercept=0)+
        theme_classic() + xlab("Mouse id") + ylab(yLab) + 
        theme(axis.text.x = element_text(angle = 40, hjust = 1))   
    return(p)
}
    
```

Extract Maximum a Posteriori estimates of intercepts and slopes. 
```{r}
## posterior summary statistics
post_summary <- function(fittedmodel, type="sol",
                         statistic=mean,
                         stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                         stringreplace="\\(Intercept\\)\\.id\\.mouse\\_")
    ## 
{
    fittedmodel$sol <- fittedmodel$sol %>% as.data.frame
    if(type=="sol")
    {
        out <- apply(fittedmodel$Sol, 2, statistic) %>%
            keep_rownames
        names(out) <- c("rname", "value") 
        out <- out %>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
            mutate(mouse.id=gsub(pattern=stringreplace,
                                 replacement="", rname)) %>%
            dplyr::select(-rname)        
    }
    if(type=="vcov")
    {
        out <- apply(fittedmodel$VCV, 2, statistic) %>%
            keep_rownames
        names(out) <- c("rname", "value")
        out <- out %>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
            mutate(mouse.id=gsub(pattern=stringreplace,
                                 replacement="", rname)) %>%
            dplyr::select(-rname)        
    }

    return(out)
}

```
Extract effective sample sizes

```{r}

## posterior summary statistics
ESS <- function(fittedmodel, type="sol",
                statistic=mean,
                stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                stringreplace="\\(Intercept\\)\\.id\\.mouse\\_")
    ## 
{
    fittedmodel$sol <- fittedmodel$sol %>% as.data.frame
    if(type=="sol")
    {
        out <- effectiveSize(fittedmodel$Sol) %>%
            keep_rownames
        names(out) <- c("rname", "value") 
        out <- out %>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
            mutate(mouse.id=gsub(pattern=stringreplace,
                                 replacement="", rname)) %>%
            dplyr::select(-rname)        
    }
    if(type=="vcov")
    {
        out <- effectiveSize(fittedmodel$VCV)%>%
            keep_rownames
        names(out) <- c("rname", "value")
        out <- out %>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
            mutate(mouse.id=gsub(pattern=stringreplace,
                                 replacement="", rname)) %>%
            dplyr::select(-rname)        
    }
    
    return(out)
}

```














