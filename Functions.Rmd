---
title: "Functions"
author: "Matt Nolan"
date: "17/05/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggthemes)
```

Goals: functions for mixed model and related analysis of multiple electrophysiological properties. Functions are removed from individual .Rmd documents so they can be re-used in multiple analyses.

----------------------- Models ------------------------

# Model vs random intercept and slope. Use this model for all main analyses (see Barr et al. Journal of Memory and Language, 2013)
model_to_fit 




```{r}
model_to_fit <- function(df) {
  lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
```

- used in Interanimal.rmd
- used in PCA.rmd




   
```{r}
## Model for random intercept and slope
model_vsris <- function(df) {
    lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}

## Null model for random intercept and slope
model_vsris_null <- function(df) {
    lme4::lmer(value ~ 1+dvlocmm||id, data = df, REML = FALSE, na.action = na.exclude)
}

## Model vs random intercept.
model_vsri <- function(df) {
    lme4::lmer(value ~ dvlocmm +(1|id), data = df, REML = FALSE, na.action = na.exclude)
}
## Null model vs random intercept.
model_vsri_null <- function(df) {
    lme4::lmer(value ~ 1|id, data = df, REML = FALSE, na.action = na.exclude)
}
## Model vs correlated random intercept and slope.
model_vscris <- function(df) {
    lme4::lmer(value ~ dvlocmm +(1+dvlocmm|id), data = df, REML = FALSE, na.action = na.exclude)
}
## Null model vs correlated random intercept and slope.
model_vscris_null <- function(df) {
  lme4::lmer(value ~ 1+dvlocmm|id, data = df, REML = FALSE, na.action = na.exclude)
}
```



```{r}
model_vsrisage <- function(df) {
    lme4::lmer(value ~ dvlocmm+age +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
model_vsrisagerectime <- function(df) {
    lme4::lmer(value ~ dvlocmm+age+rectime +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}

```

 
```{r}
linearmodel_to_fit <- function(df) {
  lm(value ~ dvlocmm, data = df, na.action = na.exclude)
}
```
- used in Interanimal.rmd
- used in PCA.rmd

Alternative way to fit mixed model using nlme for compatibility with ANOVA.
```{r}
# Gives error when random term incluces dvlocmm
nlmemodel_to_fit <- function(df) {
  nlme::lme(value ~ dvlocmm, random = ~1|id, data = df, method = "ML", na.action = na.exclude)
}
```


------------------ Helper functions ---------------------

Helper function to return model coefficients in a tidy format.
```{r}
coef_df <- function(model_name) {
  mod_coef <- coef(model_name)
  tibble(id = row.names(mod_coef[[1]]), intercept = mod_coef[[1]][[1]], slope = mod_coef[[1]][[2]])
}
```
- used in Internanimal.rmd
- used in PCA.rmd

Helper functions for chi-squared test to compare linear with mixed models.
```{r}
devcalc <- function(df){
  dev <- -2*logLik(df)
}

extractdf <- function(dev){
  attr(dev,"df")
}

# CAn this be improved? Returning a tibble / df seems a bit clunky.
mixed_vs_linear_pchisqu <- function(df){
    df <- df %>%
        mutate(dev_mixed = map(mixedmodel_vsris, devcalc)) %>%
        mutate(dev_linear = map(linearmodel, devcalc)) %>%
        mutate(devdiff = as.numeric(dev_linear) - as.numeric(dev_mixed)) %>%
        mutate(dev_mixed_df = map(dev_mixed, extractdf)) %>%
        mutate(dev_linear_df = map(dev_linear, extractdf)) %>%
        mutate(dfdiff = as.numeric(dev_mixed_df) - as.numeric(dev_linear_df)) %>%
        mutate(pdiff = pchisq(devdiff,dfdiff,lower.tail=FALSE))
    tibble(dev_mixed = df$dev_mixed,
           dev_linear = df$dev_linear,
           devdiff = df$devdiff,
           dev_mixed_df = df$dev_mixed_df,
           dev_linear_df = df$dev_linear_df,
           dfdiff = df$dfdiff,
           pdiff = df$pdiff)
}
```
- used in Internanmal.rmd
- used in PCA.rmd


Function for presentation of data.
```{r}
hist_theme = theme(
    text = element_text(size=9),
    strip.background = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank()
  )
```


Helper functions for manipulating MCMCglmm objects using tidyverse
```{r}


keep_rownames<- function(df, column.name="rname")
    ## store the rownames in new column when converting a data frame to tibble
{
    df %>%
        as.data.frame() %>%
        as_tibble() %>%
        rownames_to_column("rname")
}


HPD <- function(fittedmodel, type="sol")
    ## extract Highest Posterior Density intervals 
    ## for both fixed and random effects
    ## argument type: can take either "sol" or "vcov"
    ## sol yields intervals for betas (both fixed and random)
    ## vcov yields intervals for variances (and covariances if these
    ## (are specified in the model) of random effects and residuals     
{
    if(type=="sol")
        tmp <- HPDinterval(fittedmodel$Sol)
    if(type=="vcov")
        tmp <- HPDinterval(fittedmodel$VCV)
    ## 
    keep_rownames(tmp)
}


HPDforggplot <- function(HPDobject,
                         stringmatch="Intercept).id.mouse",
                         stringreplace="\\(Intercept\\)\\.id\\.mouse\\.")
    ## helper function to convert HPD objects to long format and extract
    ## betas from random effects. The function is a pre-step to a ggplot call.
    ## args stringmatch and stringreplace are tidying up the verbose names
    ## obtained from the MCMCglmm output
    ## stringmatch:
    ## 1. "Intercept).id.mouse", corresponds to random intercept -- default option
    ## 2. "dvlocmm.id.mouse", corresponds to random slope
    ## stringreplace:
    ## 1.  "\\(Intercept\\)\\.id\\." -- default option
    ## 2. "dvlocmm\\.id\\."
{   
    ## TODO add a stopifnot statement for consistency in use of arguments
    ## stringmatch and stringreplace
    df_long <- gather(HPDobject, HPDendpoint, value, -rname) 
    df_long%>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
        mutate(mouse.id=gsub(pattern=stringreplace,
                             replacement="", rname)) %>%
        dplyr::select(-rname)
}

ggplotHPD <- function(df, yLab="Intercept")
{
    p <- ggplot(df, aes(x=reorder(mouse.id,value),
                        y=value, group=factor(HPDendpoint))) +
        geom_line() +
        geom_point()+
        geom_hline(yintercept=0)+
        theme_classic() + xlab("Mouse id") + ylab(yLab) + 
        theme(axis.text.x = element_text(angle = 40, hjust = 1))
    
    return(p)
}
    
```

Extract Maximum a Posteriori estimates of intercepts and slopes. 
```{r}
## posterior summary statistics
post_summary <- function(fittedmodel, type="sol",
                         statistic=mean,
                         stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                         stringreplace="\\(Intercept\\)\\.id\\.mouse\\_")
    ## 
{
    fittedmodel$sol <- fittedmodel$sol %>% as.data.frame
    if(type=="sol")
    {
        out <- apply(fittedmodel$Sol, 2, statistic) %>%
            keep_rownames
        names(out) <- c("rname", "value") 
        out <- out %>% dplyr::filter(grepl(rname, pattern=stringmatch)) %>%
            mutate(mouse.id=gsub(pattern=stringreplace,
                                 replacement="", rname)) %>%
            dplyr::select(-rname)        
    }
    if(type=="vcov")
    {
        out <- apply(fittedmodel$VCV, 2, statistic) %>%
            keep_rownames
        names(out) <- c("rname", "value")
    }

    return(out)
}




gsub("\\.mouse.*", replacement="", x="(Intercept).id.mouse_20141112")

```

General purpose functions
```{r}
## vectorize grepl and gsub
greplvec <- function(vec, pattern)
{
    do.call("grepl", list(vec, pattern=pattern))
}



```









