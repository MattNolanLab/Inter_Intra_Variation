---
title: "Main Analysis"
author: "Matt Nolan"
date: "22/05/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Ensure access to libraries
library(lme4)
library(MuMIn)
library(tidyverse)
```


## Goals

Core analyses used for investigation of inter-animal variability in intrinsic properties of layer 2 stellate cells and their dorsoventral organisation. This code uses functions in "Functions.rmd".

Organisation:

Load data

Fit mixed models
Compare fits of mixed models to one another and to population level linear model
Extract other summary data from the models
Generate summary table
Plot fits of mixed models
Generate plots to evaluate assumptions of mixed models

Carry out PCA
Fit mixed models to principal components
Generate summary table
Plot fits of mixed models
Generate plots to evaluate assumptions of mixed models

## Load data

Specific properties for filtering data. Include animals ≥ 28 days.
```{r Analysis parameters}
min_age <- 0
```

Import the data, remove rows with unknown locations and summarise numbers of observations and animals. 
```{r import data, message = FALSE}
# fname.sc <- "/Users/hughpastoll/Research/stellateintrinsic/Database/datatable.txt"
fname.sc <- "/Users/mattnolan/Dropbox/Modules_data/stellateintrinsic/Database/datatable.txt"
data.import <- read_tsv(fname.sc)

# Strip out rows from data where locations are unknown (are NaN)
data.sc <- data.import %>% drop_na(dvloc)

# Convert dvloc from microns to millimetres - prevents errors in model fitting large dv values
data.sc <- mutate(data.sc, dvlocmm = dvloc/1000)

# Keep animals ≥ min_age
data.sc.old <- filter(data.sc, age >= min_age)

# Calculate total number of observations, and number in each environment
length(data.sc.old$housing)
count(data.sc.old, housing)

# Calculate number of observations per animal
counts.old <- data.sc.old %>% count(id)
summary(counts.old)
```

Reformat data for use with map and other tidyverse functions.
```{r}
data.sc_r <- data.sc %>%
  dplyr::select(vm:fi, dvlocmm, id, housing) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()
```


## Fit mixed models

Fit mixed models to all measured properties using lmer. Each model is described in its corresponding function, e.g. model_vsris, and has a corresponding null model, e.g. model_vsris_null.
```{r}
data.sc_r <- data.sc_r %>%
  mutate(mixedmodel_vsris = map(data, model_vsris))%>%
  mutate(mixedmodel_vsris_null = map(data, model_vsris_null))%>%
  mutate(mixedmodel_vsri = map(data, model_vsri))%>%
  mutate(mixedmodel_vsri_null = map(data, model_vsri_null))%>%
  mutate(mixedmodel_vscris = map(data, model_vscris))%>%
  mutate(mixedmodel_vscris_null = map(data, model_vscris))
```


## Compare fits of mixed models to one another and to population level linear model

Extract summary statistics from models with Broom (glance, tidy and augment) as these return values in data frames. Need to use summary for vsris to also obtain min, max and median slopes.
```{r Extract AIC}
data.sc_r <- data.sc_r %>%
  mutate(vsris_glance = map(mixedmodel_vsris, broom::glance)) %>%
  mutate(vsris_null_glance = map(mixedmodel_vsris_null, broom::glance)) %>%
  mutate(vsri_glance = map(mixedmodel_vsri, broom::glance)) %>%
  mutate(vscris_glance = map(mixedmodel_vscris, broom::glance)) %>%
  mutate(vsris_tidy = map(mixedmodel_vsris, broom::tidy)) %>%
  mutate(vsris_aug = map(mixedmodel_vsris, broom::augment)) %>%
  mutate(vsris_summary = map(mixedmodel_vsris, summary))
```

Extract AIC for all models
```{r Extract AIC}
data.sc_r <- data.sc_r %>% 
  mutate(AIC_vsris = map_dbl(vsris_glance, ~.$AIC)) %>%
  mutate(AIC_vsris_null = map_dbl(vsris_null_glance, ~.$AIC)) %>%
  mutate(AIC_vsri = map_dbl(vsri_glance, ~.$AIC)) %>%
  mutate(AIC_vcsris = map_dbl(vscris_glance, ~.$AIC))
```

To test whether effects of animal id are significant compare mixed model fits with linear model fits. Modified from: https://web.stanford.edu/class/psych252/section/Mixed_models_tutorial.html.
```{r Compare mixed with linear model using chisq}
## linearmodel_to_fit fits: lm(value ~ dvlocmm, data = df, na.action = na.exclude)
data.sc_r <- data.sc_r %>%
  mutate(linearmodel = map(data, linearmodel_to_fit))

data.sc_r <- bind_cols(data.sc_r, mixed_vs_linear_pchisqu(data.sc_r))
```


## Extract other summary data from the model fits

Focus on the model with random intercept and slope (mixedmodel_vsris).

Store model gradient (extracted with summary / glance), marginal and conditional R2 (extracted with r.squaredGLMM) and p-value vs null model (calculated with ANOVA vs null model). Also extract model slopes.
```{r Extract model properties}
data.sc_r <- data.sc_r %>%
  mutate(gradient_slopes = map_dbl(vsris_tidy, ~.$estimate[[2]])) %>%
  mutate(extractR2 = map(mixedmodel_vsris, r.squaredGLMM)) %>%
  mutate(marginal.r2 = map_dbl(extractR2, ~.[[1]])) %>%
  mutate(conditional.r2 = map_dbl(extractR2, ~.[[2]])) %>%
  mutate(anova = map2(mixedmodel_vsris, mixedmodel_vsris_null, ~anova(.x,.y))) %>%
  mutate(tidy_anova = map(anova, broom::tidy)) %>% 
        mutate(anova_p_val = map_dbl(tidy_anova, ~.$p.value[2]))

data.sc_r <- data.sc_r %>%
  mutate(vsris_simcoefs = map(mixedmodel_vsris, ~summary(coef(.x)[[1]][[2]]))) %>%
  mutate(modelslope_min = map_dbl(vsris_simcoefs, ~.[[1]])) %>%
  mutate(modelslope_median = map_dbl(vsris_simcoefs, ~.[[3]])) %>%
  mutate(modelslope_max = map_dbl(vsris_simcoefs, ~.[[5]]))
```


## Generate summary table

Show model fitting results as a table.
```{r Make and save table}
props_for_table <- c("property", "gradient_slopes", "modelslope_min", "modelslope_max", "anova_p_val", "marginal.r2", "conditional.r2", "pdiff")
props_table <- as.tibble(data.sc_r[props_for_table])
props_table_unnest <- unnest(props_table)

  knitr::kable(
  props_table_unnest,
  digits = 5,
  caption = "Fit of measured membrane properties as a function of location"
)

write_csv(props_table_unnest, "results_model_table.csv")
```


## Plot fits of mixed models

We want to plot for each model the prediction at location = 0 for each animal (I), the model prediction for location = 1 mm (I + S) and a line indicating the slope with start centred at the value of the population level model at location = 0.

```{r Extract model predictions for plotting}
# Obtain global intercepts for each feature.
data.sc_r <- data.sc_r %>%
  mutate(pop_intercepts = map_dbl(vsris_tidy, ~.$estimate[[1]]))

# Obtain individual intercepts and slopes for each feature.
# coef_df is a helper function to return model coefficients in a tidy formt.
# coef_df_2 also calculate I+S, etc.
data.sc_r <- data.sc_r %>%
  mutate(coefs = map2(mixedmodel_vsris, pop_intercepts, ~coef_df_2(.x, .y)))

data.sc_r_unnest <- unnest(data.sc_r, coefs) %>%
  select(property, id, ind_intercept, ind_slope, ind_intercept_slope, global_intercept, global_intercept_slope)

```

Reformat the data to generate plots.
```{r Format data ready for plotting}
ind_intercept <- select(data.sc_r_unnest, property, id, ind_intercept) %>%
  mutate(measure = "ind_intercept") %>%
  mutate(value_2 = ind_intercept)
global_intercept <- select(data.sc_r_unnest, property, id, global_intercept) %>%
  mutate(measure = "global_intercept") %>%
  mutate(value_1 = global_intercept)
ind_intercept_slope <- select(data.sc_r_unnest, property, id, ind_intercept_slope) %>%
  mutate(measure = "ind_intercept_slope") %>%
  mutate(value_2 = ind_intercept_slope)
global_intercept_slope <- select(data.sc_r_unnest, property, id, global_intercept_slope) %>%
  mutate(measure = "global_intercept_slope") %>%
  mutate(value_1 = global_intercept_slope)


combined_intercepts_slopes <- bind_rows(ind_intercept, ind_intercept_slope, global_intercept, global_intercept_slope)

id_housing <-  distinct(data.sc, id, housing)
combined_intercepts_slopes <- left_join(combined_intercepts_slopes, id_housing, by = "id")

combined_intercepts_slopes$property_factors <- as.factor(combined_intercepts_slopes$property)
combined_intercepts_slopes$property_factors = factor(combined_intercepts_slopes$property_factors, c("vm", "ir", "sag", "tau", "resf", "resmag", "rheo", "fi", "ahp", "spkmax", "spkthr", "spkhlf"))
```


Now generate the plot.
```{r Make facetted plot of model fits}
labels_intercepts <- c(ahp = "AHP min. (mV)", fi = "F-I (Hz / pA)", ir = "IR (MΩ)", resf = "Res F (Hz)", resmag = "Res. mag.", rheo = "Rheobase (pA)", sag = "Sag", spkhlf = "Spike h-w (ms)", spkmax = "Spike max. (mV)", spkthr = "Spike thres. (mV)", tau = "Tm (ms)", vm = "Vrest (mV)")

IS_figure <- ggplot(combined_intercepts_slopes, aes(x = measure, y = value_1, colour = housing)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("ind_intercept", "ind_intercept_slope", "global_intercept", "global_intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~property_factors, scales = "free",  labeller = labeller(property_factors = labels_intercepts)) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure
```

Save the figure.
```{r Save plot of model fits}
ggsave("I_S_figure.png", width = 140, height = 120, units = "mm")
```



## Generate plots to evaluate assumptions of mixed models
To test for linearity, and to assess homoscedasticity, plot residuals (.residual) versus fitted values (.fitted) generated by broom::augment.

```{r}
resid_plot_data <- unnest(data.sc_r, vsris_aug) %>%
  select(property, id, .resid, .fitted)

ggplot(resid_plot_data, aes(.fitted, .resid)) +
  geom_point() +
  facet_wrap(~property, scales = "free") +
  theme_classic()
```

Evaluate normality of residuals.
```{r}
ggplot(resid_plot_data, aes(.resid)) +
  geom_histogram() +
  facet_wrap(~property, scales = "free") +
  theme_classic()
```



## Carry out PCA

Goal is to reduce the dimensionality of the dataset and then explore how dorsoventral location and mouse identity map onto each dimension by evaluating linear models generated using the principal components.

Carry out PCA.
```{r}
data.pca <- dplyr::select(data.sc, vm:fi, dvlocmm, id, housing)
cols.pca <- 1:11

out.pca <- prcomp(data.pca[cols.pca],
                  retx = TRUE,
                  centre = TRUE,
                  scale = TRUE)

plot(out.pca)
summary(out.pca)
biplot(out.pca)
```

## View relationships between principal components

```{r Prepare data for fitting model to principal components}
out.pca.x <- as_tibble(out.pca$x)
out.pca.x$dvlocmm <- data.pca$dvlocmm
out.pca.x$id <- data.pca$id
out.pca.x$housing <- data.pca$housing
```


```{r Plot principal components versus location}
out.pca.x_g1_11 <- out.pca.x %>%
  gather("component", "value", 1:11)

pc_plot <- ggplot(data = out.pca.x_g1_11, aes(x = dvlocmm, y = value)) +
  geom_point(aes(colour = id)) +
  facet_wrap(~ component)

out.pca.x_g1_5 <- out.pca.x %>%
  gather("component", "value", 1:5)
pc1to5_plot <-ggplot(data = filter(out.pca.x_g1_5), aes(x = dvlocmm, y = value)) +
  geom_point() +
  facet_wrap(~ component) +
  theme_classic() +
  hist_theme

pc_plot
pc1to5_plot
```

Plot components against one another.
```{r}
out.pca.x_2 <- as_tibble(out.pca$x)
out.pca.x_2$dvlocmm <- data.pca$dvlocmm
out.pca.x_2$id <- data.pca$id
pairs1 <- GGally::ggpairs(out.pca.x_2,columns = c(1:4), ggplot2::aes(colour=id, alpha = 0.1))

pairs2 <- GGally::ggpairs(out.pca.x_2,columns = c(1:2), ggplot2::aes(colour=id, alpha = 0.1))

pairs1
pairs2
```

## Fit mixed models to principal components

Fit mixed models to all measured properties using lmer. Don't fit vscri as it fails to converge.
```{r}
# Reform data for use with dplyr.
out.pca.x_g <- out.pca.x %>%
  gather("component", "value", 1:11) %>%
  group_by(component) %>%
  nest()

out.pca.x_g <- out.pca.x_g %>%
  mutate(mixedmodel_vsris = map(data, model_vsris)) %>%
  mutate(mixedmodel_vsris_null = map(data, model_vsris_null)) %>%
  mutate(mixedmodel_vsri = map(data, model_vsri)) %>%
  mutate(mixedmodel_vsri_null = map(data, model_vsri_null))
```

## Compare fits of mixed models to one another and to population level linear model

Same strategy as for the raw feature data.
```{r Extract AIC}
out.pca.x_g <- out.pca.x_g %>%
  mutate(vsris_glance = map(mixedmodel_vsris, broom::glance)) %>%
  mutate(vsris_null_glance = map(mixedmodel_vsris_null, broom::glance)) %>%
  mutate(vsri_glance = map(mixedmodel_vsri, broom::glance)) %>%
  mutate(vsris_tidy = map(mixedmodel_vsris, broom::tidy)) %>%
  mutate(vsris_aug = map(mixedmodel_vsris, broom::augment)) %>%
  mutate(vsris_summary = map(mixedmodel_vsris, summary))
```

Extract AIC for all models
```{r Extract AIC}
out.pca.x_g <- out.pca.x_g %>% 
  mutate(AIC_vsris = map_dbl(vsris_glance, ~.$AIC)) %>%
  mutate(AIC_vsris_null = map_dbl(vsris_null_glance, ~.$AIC)) %>%
  mutate(AIC_vsri = map_dbl(vsri_glance, ~.$AIC))
```

Test whether effects of animal id are significant.
```{r Compare mixed with linear model using chisq}
## linearmodel_to_fit fits: lm(value ~ dvlocmm, data = df, na.action = na.exclude)
out.pca.x_g <- out.pca.x_g %>%
  mutate(linearmodel = map(data, linearmodel_to_fit))

out.pca.x_g <- bind_cols(out.pca.x_g, mixed_vs_linear_pchisqu(out.pca.x_g))
```


## Extract other summary data from the model fits

Focus on the model with random intercept and slope (mixedmodel_vsris).

Store model gradient (extracted with summary / glance), marginal and conditional R2 (extracted with r.squaredGLMM) and p-value vs null model (calculated with ANOVA vs null model). Also extract model slopes.
```{r Extract model properties}
out.pca.x_g <- out.pca.x_g %>%
  mutate(gradient_slopes = map_dbl(vsris_tidy, ~.$estimate[[2]])) %>%
  mutate(extractR2 = map(mixedmodel_vsris, r.squaredGLMM)) %>%
  mutate(marginal.r2 = map_dbl(extractR2, ~.[[1]])) %>%
  mutate(conditional.r2 = map_dbl(extractR2, ~.[[2]])) %>%
  mutate(anova = map2(mixedmodel_vsris, mixedmodel_vsris_null, ~anova(.x,.y))) %>%
  mutate(tidy_anova = map(anova, broom::tidy)) %>% 
        mutate(anova_p_val = map_dbl(tidy_anova, ~.$p.value[2]))

out.pca.x_g <- out.pca.x_g %>%
  mutate(vsris_simcoefs = map(mixedmodel_vsris, ~summary(coef(.x)[[1]][[2]]))) %>%
  mutate(modelslope_min = map_dbl(vsris_simcoefs, ~.[[1]])) %>%
  mutate(modelslope_median = map_dbl(vsris_simcoefs, ~.[[3]])) %>%
  mutate(modelslope_max = map_dbl(vsris_simcoefs, ~.[[5]]))
```


## Generate summary table for PCA

Show model fitting results as a table.
```{r Make and save table}
props_for_table_PCA <- c("component", "gradient_slopes", "modelslope_min", "modelslope_max", "anova_p_val", "marginal.r2", "conditional.r2", "pdiff")
props_table_PCA <- as.tibble(out.pca.x_g[props_for_table_PCA])
props_table_unnest_PCA <- unnest(props_table_PCA)

  knitr::kable(
  props_table_unnest_PCA,
  digits = 5,
  caption = "Fit of measured membrane properties as a function of location"
)

write_csv(props_table_unnest, "results_model_table_PCA.csv")
```


## Plot fits of mixed models of PCA data

As above, we want to plot for each model the prediction at location = 0 for each animal (I), the model prediction for location = 1 mm (I + S) and a line indicating the slope with start centred at the value of the population level model at location = 0.

```{r Extract model predictions for plotting}
# Obtain global intercepts for each feature.
out.pca.x_g <- out.pca.x_g %>%
  mutate(pop_intercepts = map_dbl(vsris_tidy, ~.$estimate[[1]]))

# Obtain individual intercepts and slopes for each feature.
# coef_df is a helper function to return model coefficients in a tidy formt.
# coef_df_2 also calculate I+S, etc.
out.pca.x_g <- out.pca.x_g %>%
  mutate(coefs = map2(mixedmodel_vsris, pop_intercepts, ~coef_df_2(.x, .y)))

out.pca.x_g_unnest <- unnest(out.pca.x_g, coefs) %>%
  select(component, id, ind_intercept, ind_slope, ind_intercept_slope, global_intercept, global_intercept_slope)

```

Reformat the data to generate plots.
```{r Format data ready for plotting}
ind_intercept_PCA <- select(out.pca.x_g_unnest, component, id, ind_intercept) %>%
  mutate(measure = "ind_intercept") %>%
  mutate(value_2 = ind_intercept)
global_intercept_PCA <- select(out.pca.x_g_unnest, component, id, global_intercept) %>%
  mutate(measure = "global_intercept") %>%
  mutate(value_1 = global_intercept)
ind_intercept_slope_PCA <- select(out.pca.x_g_unnest, component, id, ind_intercept_slope) %>%
  mutate(measure = "ind_intercept_slope") %>%
  mutate(value_2 = ind_intercept_slope)
global_intercept_slope_PCA <- select(out.pca.x_g_unnest, component, id, global_intercept_slope) %>%
  mutate(measure = "global_intercept_slope") %>%
  mutate(value_1 = global_intercept_slope)


combined_intercepts_slopes_PCA <- bind_rows(ind_intercept_PCA, ind_intercept_slope_PCA, global_intercept_PCA, global_intercept_slope_PCA)

id_housing_PCA <-  distinct(out.pca.x, id, housing)
combined_intercepts_slopes_PCA <- left_join(combined_intercepts_slopes_PCA, id_housing_PCA, by = "id")

combined_intercepts_slopes_PCA$component_factors <- as.factor(combined_intercepts_slopes_PCA$component)
combined_intercepts_slopes_PCA$component_factors = factor(combined_intercepts_slopes_PCA$component_factors, c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11"))

```


Now generate the plot.
```{r Make facetted plot of model fits}
IS_figure_PCA_1_11 <- ggplot(combined_intercepts_slopes_PCA, aes(x = measure, y = value_1, colour = housing)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("ind_intercept", "ind_intercept_slope", "global_intercept", "global_intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~component_factors) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure_PCA_1_5 <- ggplot(subset(combined_intercepts_slopes_PCA, component %in% c("PC1", "PC2", "PC3", "PC4", "PC5")), aes(x = measure, y = value_1, colour = housing)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("ind_intercept", "ind_intercept_slope", "global_intercept", "global_intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~component_factors) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure_PCA_1_11
IS_figure_PCA_1_5
```


## Generate plots to evaluate assumptions of mixed models
```{r}
ggpubr::ggarrange(pc1to5_plot, IS_figure_PCA_1_5)
```




## Save PCA plots

