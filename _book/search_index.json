[
["index.html", "Analysis code for Pastoll et al. Introduction", " Analysis code for Pastoll et al. Matt Nolan 2018-08-07 Introduction The book documents code used in Pastoll et al. Each chapter describes analyses for the corresponding figure. "],
["functions.html", "Functions", " Functions This document contains functions for code used in later sections. The functions are removed from individual .Rmd documents so they can be re-used in multiple analyses. ———————– Models ———————— Model vs random intercept and slope. Use this model for all main analyses (see Barr et al. Journal of Memory and Language, 2013) model_to_fit model_to_fit &lt;- function(df) { lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude) } used in Interanimal.rmd used in PCA.rmd # Model for uncorrelated random intercept and slope model_vsris &lt;- function(df) { lme4::lmer(value ~ dvlocmm +(dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude) } model_vsris_lT&lt;- function(df) { lmerTest::lmer(value ~ dvlocmm +(dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude) } # Null model for uncorrelated random intercept and slope model_vsris_null &lt;- function(df) { lme4::lmer(value ~ dvlocmm||id, data = df, REML = FALSE, na.action = na.exclude) } # Model vs random intercept. model_vsri &lt;- function(df) { lme4::lmer(value ~ dvlocmm +(1|id), data = df, REML = FALSE, na.action = na.exclude) } # Null model vs random intercept. model_vsri_null &lt;- function(df) { lme4::lmer(value ~ 1|id, data = df, REML = FALSE, na.action = na.exclude) } # Model vs correlated random intercept and slope. model_vscris &lt;- function(df) { lme4::lmer(value ~ dvlocmm +(dvlocmm|id), data = df, REML = FALSE, na.action = na.exclude) } # Null model vs correlated random intercept and slope. model_vscris_null &lt;- function(df) { lme4::lmer(value ~ dvlocmm|id, data = df, REML = FALSE, na.action = na.exclude) } # Model for uncorrelated random intercept and slope including housing as a fixed effect model_vsris_housing &lt;- function(df) { lme4::lmer(value ~ dvlocmm * housing + (dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude) } # Model for uncorrelated random intercept and slope including age as a fixed effect model_vsris_age &lt;- function(df) { df_na_remove &lt;- filter(df, !is.na(age)) lme4::lmer(value ~ dvlocmm * age + (dvlocmm||id), data = df_na_remove, REML = FALSE, na.action = na.exclude) } # Control model with data points without age excluded model_vsris_age_con &lt;- function(df) { df_na_remove &lt;- filter(df, !is.na(age)) lme4::lmer(value ~ dvlocmm + (dvlocmm||id), data = df_na_remove, REML = FALSE, na.action = na.exclude) } # Model for uncorrelated random intercept and slope for all possible random effects. model_vsris_all_lmerTest &lt;- function(df) { df &lt;- df %&gt;% drop_na() lmerTest::lmer(value ~ dvlocmm + (dvlocmm||id) + (dvlocmm||mlpos) + (dvlocmm||hemi) + (dvlocmm||age)+ (dvlocmm||housing) + (dvlocmm||expr) + (dvlocmm||patchdir) + (dvlocmm||rectime), data = df, REML = FALSE, na.action = na.exclude) } model_vsris_all &lt;- function(df) { df &lt;- df %&gt;% drop_na() lme4::lmer(value ~ dvlocmm + (dvlocmm||id) + (dvlocmm||mlpos) + (dvlocmm||hemi) + (dvlocmm||age)+ (dvlocmm||housing) + (dvlocmm||expr) + (dvlocmm||patchdir) + (dvlocmm||rectime), data = df, REML = FALSE, na.action = na.exclude) } model_vsris_all_PC &lt;- function(df) { df &lt;- df %&gt;% drop_na() lmerTest::lmer(value ~ dvlocmm + (dvlocmm||id) + (dvlocmm||mlpos) + (dvlocmm||age)+ (dvlocmm||housing) + (dvlocmm||expr) + (dvlocmm||patchdir), data = df, REML = FALSE, na.action = na.exclude) } model_vsris_all_NM &lt;- function(df) { df &lt;- df %&gt;% drop_na() lmerTest::lmer(value ~ dvlocmm + (dvlocmm||id) + (dvlocmm||mlpos) + (dvlocmm||hemi) + (dvlocmm||age)+ (dvlocmm||housing) + (dvlocmm||expr) + (dvlocmm||patchdir) + (dvlocmm||rectime), data = df, REML = FALSE, na.action = na.exclude, control = lmerControl(optimizer =&quot;Nelder_Mead&quot;)) } model_vsris_all_BFGS &lt;- function(df) { df &lt;- df %&gt;% drop_na() lmerTest::lmer(value ~ dvlocmm + (dvlocmm||id) + (dvlocmm||mlpos) + (dvlocmm||hemi) + (dvlocmm||age)+ (dvlocmm||housing) + (dvlocmm||expr) + (dvlocmm||patchdir) + (dvlocmm||rectime), data = df, REML = FALSE, na.action = na.exclude, control = lmerControl(optimizer =&#39;optimx&#39;, optCtrl=list(method=&#39;L-BFGS-B&#39;))) } model_vsris_all_nlminb &lt;- function(df) { df &lt;- df %&gt;% drop_na() lmerTest::lmer(value ~ dvlocmm + (dvlocmm||id) + (dvlocmm||mlpos) + (dvlocmm||hemi) + (dvlocmm||age)+ (dvlocmm||housing) + (dvlocmm||expr) + (dvlocmm||patchdir) + (dvlocmm||rectime), data = df, REML = FALSE, na.action = na.exclude, control = lmerControl(optimizer =&#39;optimx&#39;, optCtrl=list(method=&#39;nlminb&#39;))) } Linear models linearmodel_to_fit &lt;- function(df) { lm(value ~ dvlocmm, data = df, na.action = na.exclude) } linearmodel_age &lt;- function(df) { lm(value ~ dvlocmm * age, data = df, na.action = na.exclude) } linearmodel_housing &lt;- function(df) { lm(value ~ dvlocmm * housing, data = df, na.action = na.exclude) } used in Interanimal.rmd used in PCA.rmd Mixed models fit with nlme Alternative way to fit mixed model using nlme for compatibility with ANOVA. # Gives error when random term incluces dvlocmm nlmemodel_to_fit &lt;- function(df) { nlme::lme(value ~ dvlocmm, random = ~1|id, data = df, method = &quot;ML&quot;, na.action = na.exclude) } —————— Helper functions ——————— Helper function to return model coefficients in a tidy format. coef_df &lt;- function(model_name) { mod_coef &lt;- coef(model_name) tibble(id = row.names(mod_coef[[1]]), intercept = mod_coef[[1]][[1]], slope = mod_coef[[1]][[2]]) } used in Internanmal.rmd used in PCA.rmd Helper function to return model coefficients in a tidy format. This version also use gi to find the global intercept and returns global intercept and global intercept + slope. coef_df_2 &lt;- function(model_name, gi) { mod_coef &lt;- coef(model_name) tibble(id = row.names(mod_coef$id), ind_intercept = mod_coef$id[[1]], ind_slope = mod_coef$id[[2]], ind_intercept_slope = mod_coef$id[[1]] + mod_coef$id[[2]], global_intercept = gi, global_intercept_slope = gi + mod_coef$id[[2]]) } coef_df_2_old &lt;- function(model_name, gi) { mod_coef &lt;- coef(model_name) tibble(id = row.names(mod_coef[[1]]), ind_intercept = mod_coef[[1]][[1]], ind_slope = mod_coef[[1]][[2]], ind_intercept_slope = mod_coef[[1]][[1]] + mod_coef[[1]][[2]], global_intercept = gi, global_intercept_slope = gi + mod_coef[[1]][[2]]) } Helper functions for chi-squared test to compare linear with mixed models. devcalc &lt;- function(df){ dev &lt;- -2*logLik(df) } extractdf &lt;- function(dev){ attr(dev,&quot;df&quot;) } # Can this be improved? Returning a tibble / df seems a bit clunky. mixed_vs_linear_pchisqu &lt;- function(df, mixedmod, linearmod){ df &lt;- df %&gt;% mutate(dev_mixed = map(!! rlang::sym(mixedmod), devcalc)) %&gt;% mutate(dev_linear = map(!! rlang::sym(linearmod), devcalc)) %&gt;% mutate(devdiff = as.numeric(dev_linear) - as.numeric(dev_mixed)) %&gt;% mutate(dev_mixed_df = map(dev_mixed, extractdf)) %&gt;% mutate(dev_linear_df = map(dev_linear, extractdf)) %&gt;% mutate(dfdiff = as.numeric(dev_mixed_df) - as.numeric(dev_linear_df)) %&gt;% mutate(pdiff = pchisq(devdiff,dfdiff,lower.tail=FALSE)) %&gt;% select(dev_mixed, dev_linear, devdiff, dev_mixed_df, dev_linear_df, dfdiff, pdiff) df } used in Internanmal.rmd used in PCA.rmd Functions for presentation of data. hist_theme = theme( text = element_text(size=9), strip.background = element_blank(), axis.title.x=element_blank(), axis.title.y=element_blank() ) PCA_theme = theme( text = element_text(size=9), strip.background = element_blank(), axis.title.y=element_blank() ) Helper function to normalise a vector normalize&lt;-function(m){ (m - min(m, na.rm = TRUE))/(max(m, na.rm = TRUE)-min(m, na.rm = TRUE)) } Helper function to extract fit properties from a column of models stored in a dataframe and then add the output to the dataframe as additional columns. Use Broom (glance, tidy and augment) as returns values in data frames. Need to use summary to also obtain min, max and median slopes. df - a dataframe containing columns to work on mm_col - a column of df containing the mixed models fit with lmer Properties to extract are: Model gradient (extracted with summary / glance), marginal and conditional R2 (extracted with r.squaredGLMM). mixedmod_extract &lt;- function(df, mm_col){ # If want to use this for more than one model in the same data frame then will need to make names of new columns extensions of mm_col df &lt;- df %&gt;% mutate(mm_tidy = map(!! rlang::sym(mm_col), broom::tidy)) %&gt;% mutate(mm_aug = map(!! rlang::sym(mm_col), broom::augment)) %&gt;% mutate(mm_summary = map(!! rlang::sym(mm_col), summary)) df &lt;- df %&gt;% mutate(mm_tidy = map(!! rlang::sym(mm_col), broom::tidy)) %&gt;% mutate(gradient_slopes = map_dbl(mm_tidy, ~.$estimate[[2]])) %&gt;% mutate(extractR2 = map(!! rlang::sym(mm_col), r.squaredGLMM)) %&gt;% mutate(marginal.r2 = map_dbl(extractR2, ~.[[1]])) %&gt;% mutate(conditional.r2 = map_dbl(extractR2, ~.[[2]])) # To reduce clutter could remove extractR2 and mm_tidy at this point so they don&#39;t get returned? df &lt;- df %&gt;% mutate(mm_simcoefs = map(!! rlang::sym(mm_col), ~summary(coef(.x)[[1]][[2]]))) %&gt;% mutate(modelslope_min = map_dbl(mm_simcoefs, ~.[[1]])) %&gt;% mutate(modelslope_median = map_dbl(mm_simcoefs, ~.[[3]])) %&gt;% mutate(modelslope_max = map_dbl(mm_simcoefs, ~.[[6]])) # could remove vsris_simcoefs at this point } Helper function to extract model predictions in a dataframe ready for plotting. prep_int_slopes Inputs df - a dataframe containing columns to work on group_col - a column of df containing the names of each group mm_col - a column of df containing the mixed models fit with lmer Returns combined_intercepts_slopes - a data frame to be used to generate the plot prep_int_slopes &lt;- function(df, group_col, mm_col){ # Use broom::tidy to extract model fit parameters for each feature. df &lt;- df %&gt;% mutate(mm_tidy = map(!! rlang::sym(mm_col), broom::tidy)) %&gt;% mutate(pop_intercepts = map_dbl(mm_tidy, ~.$estimate[[1]])) # Obtain individual intercepts and slopes for each feature as separate columns. # coef_df is a helper function to return model coefficients in a tidy formt. # coef_df_2 also calculate I+S, etc. df &lt;- df %&gt;% mutate(coefs = map2(!! rlang::sym(mm_col), pop_intercepts, ~coef_df_2(.x, .y))) df_unnest &lt;- unnest(df, coefs) %&gt;% select(!! rlang::sym(group_col), id, ind_intercept, ind_slope, ind_intercept_slope, global_intercept, global_intercept_slope) # Make new tibble with model predictions ready for plotting ind_intercept &lt;- select(df_unnest, !! rlang::sym(group_col), id, ind_intercept) %&gt;% mutate(measure = &quot;ind_intercept&quot;) %&gt;% mutate(value_2 = ind_intercept) global_intercept &lt;- select(df_unnest, !! rlang::sym(group_col), id, global_intercept) %&gt;% mutate(measure = &quot;global_intercept&quot;) %&gt;% mutate(value_1 = global_intercept) ind_intercept_slope &lt;- select(df_unnest, !! rlang::sym(group_col), id, ind_intercept_slope) %&gt;% mutate(measure = &quot;ind_intercept_slope&quot;) %&gt;% mutate(value_2 = ind_intercept_slope) global_intercept_slope &lt;- select(df_unnest, !! rlang::sym(group_col), id, global_intercept_slope) %&gt;% mutate(measure = &quot;global_intercept_slope&quot;) %&gt;% mutate(value_1 = global_intercept_slope) combined_intercepts_slopes &lt;- bind_rows(ind_intercept, ind_intercept_slope, global_intercept, global_intercept_slope) } "],
["Con.html", "Figure 1 Schemes for intra- and inter-animal variation", " Figure 1 Schemes for intra- and inter-animal variation The goal is to generate schematic diagrams to illustrate the ideas to be tested by the analyses. First generate simulated data. Imagine a dataset describing individual cells using two quantifiable features (x and y). In this scenario different cell class could be separated using these features. Each cell class is modeled as having variance for each feature. The distribution of features of cell class A has a simple structure in which the variance is around a point. For cell class B the distribution of features is along a line. Cell classes C and D have a similar distribution to A, but are centered at different values of one or both features. numcells &lt;- 100 Cell_A &lt;- tibble(x = rnorm(numcells, 10, 1), y = rnorm(numcells, 12, 1), cell = &quot;A&quot;) Cell_B &lt;- tibble(x = runif(numcells, min = 20, max = 40) + rnorm(numcells,0,1), y = rnorm(numcells, 25, 2), cell = &quot;B&quot;) Cell_C &lt;- tibble(x = rnorm(numcells, 10, 2), y = rnorm(numcells, 35, 2), cell = &quot;C&quot;) Cell_D &lt;- tibble(x = rnorm(numcells, 30, 2), y = rnorm(numcells, 10, 2), cell = &quot;D&quot;) CellFeatures &lt;- bind_rows(Cell_A, Cell_B, Cell_C, Cell_D) Plot cell features using a colour blind friendly palette (from http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/). cbPalette &lt;- c(&quot;#E69F00&quot;, &quot;#D55E00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;) CF_plot &lt;- ggplot(CellFeatures, aes(x, y, colour = cell)) + geom_point() + xlim(0,45) + ylim(0,45) + labs(x = &quot;Feature 1&quot;, y = &quot;Feature 2&quot;, colour = &quot;Cell Type&quot;, title = &quot;Cell type separation&quot;) + scale_colour_manual(values=cbPalette) + theme_classic() + theme(legend.position = &quot;bottom&quot;, axis.ticks = element_blank(), axis.text = element_blank(), legend.text = element_blank()) CF_plot Focus on cell class B. First imagine how a distribution like the one above could be generated by pooling data from multiple animals in which the actual distribution is modular. Considered colour / intensity coding the points to reflect a functional variable, e.g. dorsoventral position in MEC. Would probaly add too much information. numcells &lt;- 20 MF_A &lt;- tibble(x = c(rnorm(numcells, 26, 0.5), rnorm(numcells, 31, 0.5), rnorm(numcells, 36, 0.5)), y = rnorm(numcells*3, 25, 2), animal = &quot;1&quot;) MF_B &lt;- tibble(x = c(rnorm(numcells, 28.5, 0.5), rnorm(numcells, 33.5, 0.5), rnorm(numcells, 38.5, 0.5)), y = rnorm(numcells*3, 25, 2), animal = &quot;2&quot;) ModularFeatures &lt;- rbind(MF_A, MF_B) MF_plot &lt;- ggplot(ModularFeatures, aes(x, y, colour = animal)) + geom_point() + xlim(20,45) + ylim(20,30) + xlab(&quot;Feature 1&quot;) + ylab(&quot;Feature 2&quot;) + theme_classic() + theme(axis.title.x=element_blank()) MF_plot Next imagine a scenarion in which the distribution in D is continuous within an animal, but for which there are inter-animal differences in the mean of feature 2. numcells &lt;- 60 OOF_A &lt;- tibble(x = runif(numcells, min = 25, max = 40) + rnorm(numcells,0,1), y = rnorm(numcells, 23, 1), animal = &quot;1&quot;) OOF_B &lt;- tibble(x = runif(numcells, min = 25, max = 40) + rnorm(numcells,0,1), y = rnorm(numcells, 27, 1), animal = &quot;2&quot;) OrthogOffsetFeatures &lt;- rbind(OOF_A, OOF_B) OOF_plot &lt;- ggplot(OrthogOffsetFeatures, aes(x, y, colour = animal)) + geom_point() + xlim(20,45) + ylim(20,30) + xlab(&quot;Feature 1&quot;) + ylab(&quot;Feature 2&quot;) + theme_classic() OOF_plot Finally, imagine a scenario in which the distribution in D is continuous within an animal but the range across the variable feature differs between animals. numcells &lt;- 60 LOF_A &lt;- tibble(x = runif(numcells, min = 25, max = 35) + rnorm(numcells,0,1), y = rnorm(numcells, 25, 2), animal = &quot;1&quot;) LOF_B &lt;- tibble(x = runif(numcells, min = 30, max = 40) + rnorm(numcells,0,1), y = rnorm(numcells, 25, 2), animal = &quot;2&quot;) LinearOffsetFeatures &lt;- rbind(LOF_A, LOF_B) LOF_plot &lt;- ggplot(LinearOffsetFeatures, aes(x, y, colour = animal)) + geom_point() + xlim(20,45) + ylim(20,30) + xlab(&quot;Feature 1&quot;) + ylab(&quot;Feature 2&quot;) + theme_classic() LOF_plot ## Warning: Removed 1 rows containing missing values (geom_point). Combine models for intra-animal variation and make plots using facets. ModularFeatures$scheme &lt;- &quot;modular&quot; OrthogOffsetFeatures$scheme &lt;- &quot;orthog&quot; LinearOffsetFeatures$scheme &lt;- &quot;linear&quot; IntraAnimal &lt;- bind_rows(ModularFeatures, OrthogOffsetFeatures, LinearOffsetFeatures) IntraAnimal$scheme &lt;- as.factor(IntraAnimal$scheme) IntraAnimal$scheme = factor(IntraAnimal$scheme, c(&quot;modular&quot;, &quot;orthog&quot;,&quot;linear&quot;)) labels_schemes &lt;- c(modular = &quot;Modular&quot;, orthog = &quot;Orthogonal&quot;, linear = &quot;Linear&quot;) IntraAnimalPlot &lt;- ggplot(IntraAnimal, aes(x, y, alpha = animal)) + geom_point(colour = cbPalette[2]) + xlim(20,45) + ylim(20,30) + labs(x = &quot;Feature 1&quot;, y = &quot;Feature 2&quot;, alpha = &quot;Animal&quot;, title = &quot;Within cell type variability&quot;) + facet_wrap(~scheme, nrow = 3, labeller = labeller(scheme = labels_schemes)) + theme_classic() + theme(strip.background = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()) + scale_alpha_discrete(range=c(0.1,1)) + theme(legend.position = &quot;bottom&quot;, legend.text = element_blank()) IntraAnimalPlot ## Warning: Removed 1 rows containing missing values (geom_point). Plot all together. Blank columns are to allow white space for insertion of labels. ConceptFigure &lt;- grid.arrange(CF_plot, IntraAnimalPlot, ncol = 4, widths = c(0.1, 1, 0.1, 1.2), layout_matrix = rbind(c(NA, 1, NA, 2))) ## Warning: Removed 1 rows containing missing values (geom_point). ConceptFigure ## TableGrob (1 x 4) &quot;arrange&quot;: 2 grobs ## z cells name grob ## 1 1 (1-1,2-2) arrange gtable[layout] ## 2 2 (1-1,4-4) arrange gtable[layout] Save the figure. ggsave(&quot;Concept_figure.png&quot;, plot = ConceptFigure, width = 160, height = 100, units = &quot;mm&quot;) "]
]
