---
title: "Inter-animal variability"
author: "Matt Nolan"
date: "13/04/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Ensure access to libraries
library(lme4)
library(MuMIn)
library(tidyverse)
library(ggpubr)
library(modelr)
library(corrplot)
library(ggthemes)
library(broom)
library(skimr)
library(GGally)
library(MCMCglmm)
library(RColorBrewer)
library(glmnet)
library(gridExtra)
library(ggraph)
library(igraph)
library(corpcor)
library(tidygraph)

```
Source functions

```{r}
source_rmd("Functions.Rmd")
```

## Goals

To evaluate interanimal differences in properties of L2SCs.

Specific properties for filtering data. Include animals ≥ 28 days.
```{r}
min_age <- 0
```

Import the data, remove rows with unknown locations and summarise numbers of observations and animals. 
```{r import data, message = FALSE}

## fname.sc <- "/Users/hughpastoll/Research/stellateintrinsic/Database/datatable.txt"
start.dir <- "~/Dropbox/org/Research/Software/R/Modular_Intrinsic_Properties/"
fname.sc <- "datatable.txt"

data.import <- read_tsv(paste0(start.dir, fname.sc))

# Strip out rows from data where locations are unknown (are NaN)
data.sc <- data.import %>% drop_na(dvloc)

# Convert dvloc from microns to millimetres - prevents errors in model fitting large dv values
data.sc <- mutate(data.sc, dvlocmm = dvloc/1000)

# Keep animals ≥ min_age
data.sc.old <- filter(data.sc, age >= min_age)

# Calculate total number of observations, and number in each environment
length(data.sc.old$housing)
count(data.sc.old, housing)

# Calculate number of observations per animal
counts.old <- data.sc.old %>% count(id)
summary(counts.old)
```

Visualize all pairwise dependencies between measured properties
```{r}
## vizualise on a common N(0,1) scale
edf <- function(x) rank(x)/(1+length(x))

data.sc %>% dplyr::select(vm:fi) %>%
    apply(2, edf) %>% apply(2, qnorm) %>%
    pairs
## contrast with original scale
data.sc %>% dplyr::select(vm:fi) %>%
    pairs
```

Reformat data for use with map and other tidyverse functions.
```{r}

data.sc_long <- data.sc %>%
    gather("property", "value", vm:fi) 

data.sc_r <- data.sc %>%
    dplyr::select(vm:fi, dvlocmm, id, housing) %>%
    gather("property", "value", vm:fi) %>%
    group_by(property) %>%
    nest()
```

Obtain partial correlation and visualize the conditional independence
graph.
```{r}
data.sc_neurons <- data.sc %>% dplyr::select(vm:fi) %>% na.omit
N               <- nrow(data.sc)
Rho_neurons     <- cor(data.sc_neurons)
tol             <- 1.96/sqrt(N)           # rough approximation for
                                          # significance of partial
                                          # correlation.  Samples not
                                          # independent due to
                                          # multiple measurements for
                                          # each mouse.  TODO: adjust
                                          # tolerance level according
                                          # to efficient sample size
tol            <- 2*tol
Q_neurons      <- cor2pcor(Rho_neurons)
Q_neurons      <- Q_neurons %>% as.data.frame
g              <- graph.adjacency(abs(Q_neurons)>tol,
                               mode="undirected", diag=FALSE)
V(g)$class     <- data.sc_r$property
V(g)$degree    <- degree(g)
edge_width    <- NULL
edge_colour      <- NULL
k <- 0
for(i in 1:(ncol(Q_neurons)-1))
{
  for(j in (i+1):ncol(Q_neurons))
    if(abs(Q_neurons[i,j])>tol)
    {
      k<-k+1
      edge_width[k] <- abs(Q_neurons[i,j])/2
      edge_colour[k]   <- ifelse(Q_neurons[i,j] > 0 , 1, 3)
    }
}
E(g)$width     <- edge_width
E(g)$colour    <- edge_colour
graph          <- as_tbl_graph(g)
##


p <- ggraph(graph, 'igraph', algorithm = 'dh') +
    ## ggraph(graph, layout= "kk") +
    geom_node_circle(aes( r=.4), fill="orange", colour="black")+
    geom_edge_fan(aes(width = edge_width, color= colour), 
                  show.legend = FALSE,
                  start_cap = circle(1.4, 'cm'),
                  end_cap = circle(1.4,  'cm'),
                  lineend = "butt") +
    ## scale_edge_color_hue(colour=c("black","gray"))+
    geom_node_text(aes(label=class),
                   size=6, nudge_x=.0, nudge_y=0.0, colour="blue") +
    coord_fixed()+ 
    theme_graph(foreground = 'steelblue', fg_text_colour = 'white')

p
## ggsave(filename="CIG_neurons.pdf")

```

Model assessment
```{r}
for(j in 1:nrow(data.sc_r))
{
    p2 <-
        ggplot(data = data.frame(st.residuals=residuals(data.sc_r$mixedmodel_vscris[[j]])/
                                     sd(residuals(data.sc_r$mixedmodel_vscris[[j]])))) +
        stat_qq(aes(sample=st.residuals)) + 
        geom_abline(intercept = 0, slope = 1)
    p1 <- pp_check(data.sc_r$mixedmodel_vsrisc_stan[[j]])
    grid.arrange(p1, p2, nrow=1)
    a <- grid.arrange(p1, p2, nrow=1)
    ggsave(a, filename="MA_"%+%data.sc_r$property[j]%+%".pdf", width=13)
}

## ----------------------------------------------------------------
qqnorm(); abline(a=0,b=1); 
```



Fit mixed models to all measured properties using lmer, MCMCglmm and rstanarm
```{r}
# model_to_fit moved to functions.
                                        # lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)

## about ?h to fit all models on Thinkpad X1 Carbon
## TODO: write an Rscript that implements code on cluster

data.sc_r <- data.sc_r %>%
    mutate(mixedmodel_vsris              = map(data, model_vsris))      %>%
    mutate(mixedmodel_vsris_null         = map(data, model_vsris_null)) %>%
    mutate(mixedmodel_vsri               = map(data, model_vsri))       %>%
    mutate(mixedmodel_vsri_null          = map(data, model_vsri_null))  %>%
    mutate(mixedmodel_vscris             = map(data, model_vscris))     %>%
    mutate(mixedmodel_vscris_null        = map(data, model_vscris))     %>%
    mutate(mixedmodel_vsri_null_stan     = map(data, model_vsri_null_stan)) %>%
    mutate(mixedmodel_vsri_stan          = map(data, model_vsri_stan)) %>%
    mutate(mixedmodel_vsris_null_stan    = map(data, model_vsris_null_stan))  %>%
    mutate(mixedmodel_vsris_stan         = map(data, model_vsris_stan)) %>%
    mutate(mixedmodel_vsrisc_null_stan   = map(data, model_vsrisc_null_stan)) %>%
    mutate(mixedmodel_vsrisc_stan        = map(data, model_vsrisc_stan)) %>%
    mutate(mixedmodel_vsri_null_McMC     = map(data, model_vsri_null_McMC))  %>%
    mutate(mixedmodel_vsri_McMC          = map(data, model_vsri_McMC))  %>%
    mutate(mixedmodel_vsris_McMC         = map(data, model_vsris_McMC))      %>%
    mutate(mixedmodel_vsris_null_McMC    = map(data, model_vsris_null_McMC)) %>%
    mutate(mixedmodel_vsrisc_McMC        = map(data, model_vsrisc_McMC)) %>%
    mutate(mixedmodel_vsrisc_null_McMC   = map(data, model_vsrisc_null_McMC))

save(list=ls(),file = "modelfits_and_summaries.RData")




data.sc_r <- data.sc_r %>%
    mutate(ppc_stan_vsri = mixedmodel_vsri_stan) %>%
    mutate(ppc_stan_vsris = mixedmodel_vsris_stan) %>%
    mutate(ppc_stan_vsrisc = mixedmodel_vsrisc_stan)


```    



Add model predictions. Using predict adds a prediction for each
location, using broom::augment adds predictions (.mu) and residuals
(.wtres).
```{r}
data.sc_r <- data.sc_r %>%
  mutate(fit = map(mixedmodel_vsris, predict))

data.sc_r <- data.sc_r %>%
    mutate(fits = map(mixedmodel_vsris, broom::augment))

data.sc_r <- data.sc_r %>%
  mutate(fit_stan= map(mixedmodel_vsrisc_stan, posterior_predict)) 

data.sc_r <- data.sc_r %>%
  mutate(fits_stan= map(mixedmodel_vsrisc_stan, broom::augment))


```

Add model metrics (with glance) and summaries (with tidy). Not used to
make the figures below, but useful.
```{r}
data.sc_r <- data.sc_r %>%
  mutate(glance = map(mixedmodel_vsris, broom::glance)) %>%
  mutate(tidy = map(mixedmodel_vsris, broom::tidy))
```

Extract coefficients for individual mice. The function is to convert
the output of coef() to a dataframe so it will work with unnest.
```{r}
# coef_df is a helper function to return model coefficients in a tidy format.
data.sc_r <- data.sc_r %>%
    mutate(coefs = map(mixedmodel_vsris, coef_df)) %>%
    mutate(coefs_vsris_stan = map(mixedmodel_vsris_stan, coef_df)) %>%
    mutate(coefs_vsrisc_stan = map(mixedmodel_vsrisc_stan, coef_df))    
```

Convert data from the nested format so that we can make plots of the
fitted data.
```{r}
data.sc_r_fit <- data.sc_r %>%
  unnest(data, fit)
```

Compare different model with null models.
```{r}
# Store model gradient (extracted with summary), marginal and conditional R2 (extracted with r.squaredG LMM) and p-value vs null model (calculated with ANOVA vs null model).
data.sc_r <- data.sc_r %>%
    mutate(vsris_summary = map(mixedmodel_vsris, summary)) %>%
    mutate(vsris_null_summary = map(mixedmodel_vsris_null, summary)) %>%
    mutate(vsri_summary = map(mixedmodel_vsri, summary)) %>%
    mutate(vscris_summary = map(mixedmodel_vscris, summary)) %>%
    mutate(gradient_slopes = map_dbl(vsris_summary, ~.$coefficients[[2]])) %>%
    mutate(extractR2 = map(mixedmodel_vsris, r.squaredGLMM)) %>%
    mutate(marginal.r2 = map_dbl(extractR2, ~.[[1]])) %>%
    mutate(conditional.r2 = map_dbl(extractR2, ~.[[2]])) %>%
    mutate(anova = map2(mixedmodel_vsris, mixedmodel_vsris_null, ~anova(.x,.y))) %>%
    mutate(tidy_anova = map(anova, broom::tidy)) %>% 
    mutate(anova_p_val = map_dbl(tidy_anova, ~.$p.value[2]))

                                        # Extract model slopes
data.sc_r <- data.sc_r %>%
    mutate(vsris_simcoefs    = map(mixedmodel_vsris, ~summary(coef(.x)[[1]][[2]]))) %>%
    mutate(modelslope_min    = map_dbl(vsris_simcoefs, ~.[[1]])) %>%
    mutate(modelslope_median = map_dbl(vsris_simcoefs, ~.[[3]])) %>%
    mutate(modelslope_max    = map_dbl(vsris_simcoefs, ~.[[6]]))


data.sc_r <- data.sc_r %>%
    mutate(vsris_simcoefs     = map(mixedmodel_vsris, ~summary(coef(.x)[[1]][[2]]))) %>%
    mutate(modelslope_min     = map_dbl(vsris_simcoefs, ~.[[1]])) %>%
    mutate(modelslope_median  = map_dbl(vsris_simcoefs, ~.[[3]])) %>%
    mutate(modelslope_max     = map_dbl(vsris_simcoefs, ~.[[6]]))

# Extract AIC and DIC for all models
data.sc_r <- data.sc_r %>% 
    mutate(AIC_vsris             = map_dbl(vsris_summary, ~.$AIC[[1]])) %>%
    mutate(AIC_vsris_null        = map_dbl(vsris_null_summary, ~.$AIC[[1]])) %>%
    mutate(AIC_vsri              = map_dbl(vsri_summary, ~.$AIC[[1]])) %>%
    mutate(AIC_vcsris            = map_dbl(vscris_summary, ~.$AIC[[1]])) %>%
    mutate(DIC_vsris_McMC       = map(mixedmodel_vsris_McMC, ~.$DIC)) %>%
    mutate(DIC_vsris_null_McMC  = map(mixedmodel_vsris_null_McMC, ~.$DIC)) %>%
    mutate(DIC_vsri_McMC        = map(mixedmodel_vsri_McMC, ~.$DIC)) %>%
    mutate(DIC_vsri_null_McMC   = map(mixedmodel_vsri_null_McMC, ~.$DIC)) %>%
    mutate(DIC_vsrisc_McMC      = map(mixedmodel_vsrisc_McMC, ~.$DIC)) %>%
    mutate(DIC_vsrisc_null_McMC = map(mixedmodel_vsrisc_null_McMC, ~.$DIC))


DICdat <- bind_rows(data.sc_r %>% dplyr::
                    select(property, contains("DIC"))) %>% as.data.frame 

DICdat_long           <-  gather(DICdat, model, value, -property)
DICdat_long$value     <-  unlist(DICdat_long$value)
DICdat_long$model     <-  factor(DICdat_long$model)
DICdat_long$property  <-  factor(DICdat_long$property)

ggplot(data=DICdat_long) +
    geom_line(aes(x=reorder(model,-value), y=value, group=property)) +
    facet_wrap(~property, scales="free") + ylab("DIC") +
    xlab("model") + theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
## TODO mutate an actual model name column: strip away DIC and 
## TODO move code to plots section




```


Obtain 95% high posterior density intervals
```{r}
data.sc_r <- data.sc_r %>%
    mutate(HPDsol_vsri_McMC    = map(mixedmodel_vsri_McMC, HPD,
                                      type="sol")) %>%
    mutate(HPDsol_vsris_McMC   = map(mixedmodel_vsris_McMC, HPD,
                                      type="sol")) %>%
    mutate(HPDsol_vsrisc_McMC  = map(mixedmodel_vsrisc_McMC, HPD,
                                      type="sol")) %>%
    mutate(HPDvcov_vsri_McMC   = map(mixedmodel_vsri_McMC, HPD,
                                      type="vcov")) %>%
    mutate(HPDvcov_vsris_McMC  = map(mixedmodel_vsris_McMC, HPD,
                                      type="vcov")) %>%
    mutate(HPDvcov_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, HPD,
                                      type="vcov"))



data.sc_r <- data.sc_r %>%
    ## Random intercepts
    mutate(HPDri_vsri_McMC=map(HPDsol_vsri_McMC,
                                HPD_nonverbose,
                                stringmatch="Intercept).id.mouse",
                                stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))        %>%
    mutate(HPDri_vsris_McMC=map(HPDsol_vsris_McMC,
                                 HPD_nonverbose,
                                 stringmatch="Intercept).id.mouse",
                                 stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))      %>%
    mutate(HPDri_vsrisc_McMC=map(HPDsol_vsrisc_McMC,
                                  HPD_nonverbose,
                                  stringmatch="Intercept).id.mouse",
                                  stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))   %>%
    ## Random slopes
    mutate(HPDrs_vsris_McMC=map(HPDsol_vsris_McMC,
                                 HPD_nonverbose,
                                 stringmatch="dvlocmm.id.mouse",
                                 stringreplace="dvlocmm\\.id\\.mouse\\_"))      %>%
    mutate(HPDrs_vsrisc_McMC=map(HPDsol_vsrisc_McMC,
                                  HPD_nonverbose,
                                  stringmatch="dvlocmm.id.mouse",
                                  stringreplace="dvlocmm\\.id\\.mouse\\_")) 
    ## variance-covariance



```


Obtain posterior mean of all coefficients
```{r}
data.sc_r <- data.sc_r%>%
    mutate(PMri_vsri_McMC   = map(mixedmodel_vsri_McMC, post_summary,
                                    type="sol", statistic=median,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(PMri_vsris_McMC  = map(mixedmodel_vsris_McMC, post_summary,
                                    type="sol", statistic=median,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(PMri_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, post_summary,
                                    type="sol", statistic=median,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(PMrs_vsris_McMC  = map(mixedmodel_vsris_McMC, post_summary,
                                    type="sol", statistic=median,
                                    stringmatch="dvlocmm\\.id\\.mouse.*",
                                    stringreplace="dvlocmm\\.id\\.mouse\\_"))          %>%
    mutate(PMrs_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, post_summary,
                                    type="sol", statistic=median,
                                    stringmatch="dvlocmm\\.id\\.mouse.*",
                                    stringreplace="dvlocmm\\.id\\.mouse\\_"))          %>%
    mutate(PMvcov_vsri_McMC   = map(mixedmodel_vsri_McMC, post_summary,
                                     type="vcov", statistic=median,
                                     stringmatch=".*",
                                     stringreplace=""))                                %>%
    mutate(PMvcov_vsris_McMC  = map(mixedmodel_vsris_McMC, post_summary,
                                     type="vcov", statistic=median,
                                     stringmatch=".*",
                                     stringreplace="")) %>%
    mutate(PMvcov_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, post_summary,
                                     type="vcov", statistic=median,
                                     stringmatch="\\.*",
                                     stringreplace=""))
```        


Obtain effective sample sizes from McMC chains

```{r import, message=FALSE, warning=FALSE}
data.sc_r <- data.sc_r%>%
    mutate(ESSri_vsri_McMC   = map(mixedmodel_vsri_McMC, ESS,
                                    type="sol", statistic=mean,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(ESSri_vsris_McMC  = map(mixedmodel_vsris_McMC, ESS,
                                    type="sol", statistic=mean,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(ESSri_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, ESS,
                                    type="sol", statistic=mean,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(ESSrs_vsris_McMC  = map(mixedmodel_vsris_McMC, ESS,
                                    type="sol", statistic=mean,
                                    stringmatch="dvlocmm\\.id\\.mouse.*",
                                    stringreplace="dvlocmm\\.id\\.mouse\\_"))          %>%
    mutate(ESSrs_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, ESS,
                                    type="sol", statistic=mean,
                                    stringmatch="dvlocmm\\.id\\.mouse.*",
                                    stringreplace="dvlocmm\\.id\\.mouse\\_"))          %>%
    mutate(ESSvcov_vsri_McMC   = map(mixedmodel_vsri_McMC, ESS,
                                     type="vcov", statistic=mean,
                                     stringmatch=".*",
                                     stringreplace=""))                                %>%
    mutate(ESSvcov_vsris_McMC  = map(mixedmodel_vsris_McMC, ESS,
                                     type="vcov", statistic=mean,
                                     stringmatch=".*",
                                     stringreplace=""))                                %>%
    mutate(ESSvcov_vsrisc_McMC = map(mixedmodel_vsrisc_McMC, ESS,
                                     type="vcov", statistic=mean,
                                     stringmatch="\\.*",
                                     stringreplace=""))

```
Merging HPD intervals and posterior means in a single data frame
```{r}
data.sc_r<- data.sc_r %>%
    mutate(ri_coefs_HPD_vsri_McMC=map2(HPDri_vsrisc_McMC, PMri_vsri_McMC, inner_join)) %>%
    mutate(ri_coefs_HPD_vsris_McMC=map2(HPDri_vsrisc_McMC, PMri_vsris_McMC, inner_join)) %>%
    mutate(ri_coefs_HPD_vsrisc_McMC=map2(HPDri_vsrisc_McMC, PMri_vsrisc_McMC, inner_join)) %>%
    mutate(rs_coefs_HPD_vsris_McMC=map2(HPDrs_vsrisc_McMC, PMrs_vsris_McMC, inner_join)) %>%
    mutate(rs_coefs_HPD_vsrisc_McMC=map2(HPDrs_vsrisc_McMC, PMrs_vsrisc_McMC, inner_join))

data.sc_r<- data.sc_r %>%
    mutate(pl_ri_coefs_HPD_vsri_McMC=map(ri_coefs_HPD_vsri_McMC, ggplotHPD)) %>%
    mutate(pl_ri_coefs_HPD_vsris_McMC=map(ri_coefs_HPD_vsris_McMC, ggplotHPD)) %>%
    mutate(pl_ri_coefs_HPD_vsrisc_McMC=map(ri_coefs_HPD_vsrisc_McMC, ggplotHPD)) %>%
    mutate(pl_rs_coefs_HPD_vsris_McMC=map(rs_coefs_HPD_vsris_McMC, ggplotHPD)) %>%
    mutate(pl_rs_coefs_HPD_vsrisc_McMC=map(rs_coefs_HPD_vsrisc_McMC, ggplotHPD))

```


```{r}
## linearmodel_to_fit fits: lm(value ~ dvlocmm, data = df, na.action = na.exclude)
data.sc_r <- data.sc_r %>%
  mutate(linearmodel = map(data, linearmodel_to_fit))

data.sc_r <- bind_cols(data.sc_r, mixed_vs_linear_pchisqu(data.sc_r))
```


Show model fitting results as a table.
```{r}
props_for_table <- c("property", "gradient_slopes", "modelslope_min",
                     "modelslope_max", "anova_p_val", "marginal.r2",
                     "conditional.r2", "pdiff") ## !!! review modelslope_max
props_table <- as.tibble(data.sc_r[props_for_table])
props_table_unnest <- unnest(props_table)

  knitr::kable(
  props_table_unnest,
  digits = 5,
  caption = "Fit of measured membrane properties as a function of location"
)

write_csv(props_table_unnest, "results_model_table.csv")
```





------------------------ Make plots ----------------------
```{r}
ggplot(data.sc_r_fit, aes(x = dvlocmm, y = value, colour = housing)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property, scales = "free")
```

Extract individual slopes and intercepts from model fits.
```{r}
data.sc_r_coefs <- data.sc_r %>%
    unnest(coefs)

data.sc_r_coefs_vsris_stan <- data.sc_r %>%
    unnest(coefs_vsris_stan)

data.sc_r_coefs_vsrisc_stan <- data.sc_r %>%
    unnest(coefs_vsrisc_stan)
```


Plot distributions of intercepts.
```{r}
labels_intercepts <- c(ahp = "AHP min. (mV)", fi = "F-I (Hz / pA)", ir = "IR (MΩ)", resf = "Res F (Hz)", resmag = "Res. mag.", rheo = "Rheobase (pA)", sag = "Sag", spkhlf = "Spike h-w (ms)", spkmax = "Spike max. (mV)", spkthr = "Spike thres. (mV)", tau = "Tm (ms)", vm = "Vrest (mV)")


## MLE
intercept_histograms <- ggplot(data.sc_r_coefs, aes(intercept)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_intercepts)) +
  theme_classic() +
  hist_theme


intercept_histograms

## Bayes [fitted using STAN]
intercept_vsris_stan_histograms <- ggplot(data.sc_r_coefs_vsris_stan, aes(intercept)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_intercepts)) +
  theme_classic() +
  hist_theme

intercept_vsris_stan_histograms

## Bayes [fitted using STAN]
intercept_vsrisc_stan_histograms <- ggplot(data.sc_r_coefs_vsrisc_stan, aes(intercept)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_intercepts)) +
  theme_classic() +
  hist_theme

intercept_vsrisc_stan_histograms

```

Plot intercepts as violin plots. Could try using geom_blank here to set the scales.
```{r}
intercept_violins <- ggplot(data.sc_r_coefs, aes(x = property, y = intercept)) +
  geom_violin() +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) 
intercept_violins

intercept_violins <- ggplot(data.sc_r_coefs_vsris_stan, aes(x = property, y = intercept)) +
  geom_violin() +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) 
intercept_violins

intercept_vsris_violins <- ggplot(data.sc_r_coefs_vsris_stan, aes(x = property, y = intercept)) +
  geom_violin() +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) 
intercept_vsris_violins
```


Plot distributions of slopes.
```{r}
labels_slopes <- c(ahp = "AHP (mV / mm)", fi = "F-I (Hz / pA mm)", ir = "IR (MΩ / mm)", resf = "Res F (Hz / mm)", resmag = "Res mag (/ mm)", rheo = "Rheobase (pA / mm)", sag = "Sag (/ mm)", spkhlf = "Spike half-width (ms / mm)", spkmax = "Spike maximum (mV / mm)", spkthr = "Spike Threshold (mV / mm)", tau = "Tm (ms / mm)", vm = "Vrest (mV / mm)")

slope_histograms <- ggplot(data.sc_r_coefs, aes(slope)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_slopes)) +
  theme_classic() +
  hist_theme

slope_histograms

slope_vsris_histograms <- ggplot(data.sc_r_coefs_vsris_stan, aes(slope)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_slopes)) +
  theme_classic() +
  hist_theme

slope_vsris_histograms


slope_vsrisc_histograms <- ggplot(data.sc_r_coefs_vsrisc_stan, aes(slope)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_slopes)) +
  theme_classic() +
  hist_theme

slope_histograms
x11()
slope_vsrisc_histograms



```

Plot slopes as violin plots.
```{r}
slope_violins <- ggplot(data.sc_r_coefs, aes(x = property, y = slope)) +
  geom_jitter(height = 0, width = 0.2) +
    facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  )
slope_violins
```

```{r}
data.sc_r_fits      <- data.sc_r %>% unnest(fits)
data.sc_r_fits_stan <- data.sc_r %>% unnest(fits_stan)

data.sc_r_fits_joined <-
    inner_join(data.sc_r_fits %>% dplyr::select(dvlocmm,.fitted, id, value, property),
    (data.sc_r_fits_stan%>% dplyr::select(dvlocmm,.fitted, id, value, property)),
    by=c("id", "dvlocmm", "value", "property"))

ggplot(data.sc_r_fits_stan)+
    geom_line(aes(x=dvlocmm, y=.fitted, group=id, colour=id), linetype="dashed") +
    geom_line(aes(x=dvlocmm, y=value, alpha=0.02, group=id, colour=id)) +
    facet_wrap(~property, scales = "free") 

ggplot(data.sc_r_fits_joined) +
    geom_line(aes(x=dvlocmm, y=.fitted.x, group=id, colour=id), linetype="dashed") +
    geom_line(aes(x=dvlocmm, y=.fitted.y, group=id, colour=id), linetype="solid") +
    facet_wrap(~property, scales = "free")

```

<!-- EOS -->

Add slope to intercept to predict values at 1 mm for each mouse.
```{r}
data.sc_r_coefs$is <- data.sc_r_coefs$intercept + data.sc_r_coefs$slope
```

To enable plotting of slopes on the same graph, but seperately from the intercepts, make columns containing population intercepts, and population intercept + slope for each mouse.
```{r}
pop_intercepts <- unnest(data.sc_r, tidy) %>% filter(term == "(Intercept)") %>% dplyr::select(property, estimate)
data.sc_r_coefs_regather <- data.sc_r_coefs %>%
  dplyr::select(property, id, slope) %>%
  spread(key = id, value = slope) %>%
  left_join(pop_intercepts, by = "property") %>%
  gather("id", "slope", -estimate, -property) %>%
  mutate(intercept_slope = estimate + slope) %>%
  dplyr::select(property, id, estimate, intercept_slope) %>%
  gather(measure, value, estimate, intercept_slope)
```



Plot predicted values at 0 mm and at 1mm for each mouse.
```{r}
data.sc_r_coefs_01 <- data.sc_r_coefs %>%
  dplyr::select(id, property, intercept, is) %>%
  gather(measure, value, intercept, is)
intercept_slope_plot_a <- ggplot(data.sc_r_coefs_01, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_b <- ggplot(data.sc_r_coefs_01, aes(x = measure, y = value)) +
  geom_jitter(width = 0.2, height = 0) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_a
intercept_slope_plot_b
```

Make plots of slopes.
```{r}
slope_plot <- ggplot(data.sc_r_coefs_regather, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme

slope_plot
```

Combine plots of intercept and slopes. Need to combine data.sc_r_coefs_01 and data.sc_r_coefs_regather and add housing. Make property into factors to enable ordering of plots. Then make appropriately faceted plots.
```{r}
data.sc_r_coefs_regather <- mutate(data.sc_r_coefs_regather, value_1 = value)
data.sc_r_coefs_01 <- mutate(data.sc_r_coefs_01, value_2 = value)
combined_intercepts_slopes <- bind_rows(data.sc_r_coefs_regather, data.sc_r_coefs_01)

id_housing <-  distinct(data.sc, id, housing)
combined_intercepts_slopes <- left_join(combined_intercepts_slopes, id_housing, by = "id")

combined_intercepts_slopes$property_factors <- as.factor(combined_intercepts_slopes$property)
combined_intercepts_slopes$property_factors = factor(combined_intercepts_slopes$property_factors, c("vm", "ir", "sag", "tau", "resf", "resmag", "rheo", "fi", "ahp", "spkmax", "spkthr", "spkhlf"))

IS_figure <- ggplot(combined_intercepts_slopes, aes(x = measure, y = value_1, colour = housing)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("intercept", "is",  "estimate", "intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~property_factors, scales = "free",  labeller = labeller(property_factors = labels_intercepts)) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure
```

Save the figure.
```{r}
ggsave("I_S_figure.png", width = 140, height = 120, units = "mm")
```



Save the plots as vector graphics.
```{r}
svg(filename = "I_S_figure.png", width=6, height=4)
IS_figure
dev.off()
```

Look at relationships between the intercepts.
```{r}
combined_intercepts_slopes_si <- dplyr::select(data.sc_r_coefs, property, id, intercept)  %>%
  spread(property, intercept)
ggpairs(combined_intercepts_slopes_si,columns = c(2:13),
         lower = list(
          continuous = "points",
          mapping = aes(colour = id)
        ),
        ggplot2::aes(alpha = 0.1))
```

Look at relationships between the slopes
```{r}
combined_intercepts_slopes_ss <- dplyr::select(data.sc_r_coefs, property, id, slope)  %>%
  spread(property, slope)
ggpairs(combined_intercepts_slopes_ss,columns = c(2:13),
        lower = list(
          continuous = "points",
          mapping = aes(colour = id)
        ),
        ggplot2::aes(alpha = 0.1))
```



Now repeat with normalised data.

Normalise property measurements.
```{r}
normalize<-function(m){
   (m - min(m, na.rm = TRUE))/(max(m, na.rm = TRUE)-min(m, na.rm = TRUE))
}

data.sc.norm <- as.data.frame(lapply(data.sc[1:12], normalize))
data.sc.norm$dvlocmm <- data.sc$dvlocmm
data.sc.norm$id <- data.sc$id

```

Analysis is as above. Loop through the data.
1. Create a model for each measured parameter.
2. Store plots for fitted slopes for each mouse.
```{r}
##     theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}

do.call("grid.arrange", data.sc_r$pl_ri_coefs_HPD_vsri_McMC)
do.call("grid.arrange", data.sc_r$pl_ri_coefs_HPD_vsris_McMC)
do.call("grid.arrange", data.sc_r$pl_ri_coefs_HPD_vsrisc_McMC)
do.call("grid.arrange", data.sc_r$pl_rs_coefs_HPD_vsris_McMC)
do.call("grid.arrange", data.sc_r$pl_rs_coefs_HPD_vsrisc_McMC)


```



Compare linear models with mixed models. Does adding random effects lead to a statistically different model? 

Test whether effects of animal id are significant compare mixed model fits with linear model fits. Modified from: https://web.stanford.edu/class/psych252/section/Mixed_models_tutorial.html.
```{r Compare mixed with linear model using chisq}
# reformat data
data.sc.norm_r <- data.sc.norm %>%
  select(vm:fi, dvlocmm, id) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()

# apply lmer to all measurements
model_to_fit <- function(df) {
  lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(mixedmodel = map(data, model_to_fit))

# add predictions
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fit = map(mixedmodel, predict))
# or this? gives predictions as .mu.
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fits = map(mixedmodel, broom::augment))

# add model metrics
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(glance = map(mixedmodel, broom::glance))

# extract data
data.sc.norm_r_fit <- data.sc.norm_r %>%
  unnest(data, fit)

# make plots
ggplot(data.sc.norm_r_fit, aes(x = dvlocmm, y = value)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property)


```




        
