---
title: "Inter-animal variability"
author: "Matt Nolan"
date: "13/04/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Ensure access to libraries
library(lme4)
library(MuMIn)
library(tidyverse)
library(ggpubr)
library(corrplot)
library(modelr)
library(ggthemes)
library(broom)
```

## Goals

To evaluate interanimal differences in properties of L2SCs.

Specific properties for filtering data. Include animals ≥ 28 days.
```{r}
min_age <- 0
```

Import the data, remove rows with unknown locations and summarise numbers of observations and animals. 
```{r import data, message = FALSE}
# fname.sc <- "/Users/hughpastoll/Research/stellateintrinsic/Database/datatable.txt"
fname.sc <- "/Users/mattnolan/Dropbox/Modules_data/stellateintrinsic/Database/datatable.txt"
data.import <- read_tsv(fname.sc)

# Strip out rows from data where locations are unknown (are NaN)
data.sc <- data.import %>% drop_na(dvloc)

# Convert dvloc from microns to millimetres - prevents errors in model fitting large dv values
data.sc <- mutate(data.sc, dvlocmm = dvloc/1000)

# Keep animals ≥ min_age
data.sc.old <- filter(data.sc, age >= min_age)

# Calculate total number of observations, and number in each environment
length(data.sc.old$housing)
count(data.sc.old, housing)

# Calculate number of observations per animal
counts.old <- data.sc.old %>% count(id)
summary(counts.old)
```

Reformat data for use with map and othe rtidy tidyverse functions.
```{r}
data.sc_r <- data.sc %>%
  dplyr::select(vm:fi, dvlocmm, id, housing) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()
```

Fit mixed models to all measured properties using lmer
```{r}
# model_to_fit moved to functions.
# lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
data.sc_r <- data.sc_r %>%
  mutate(mixedmodel_vsris = map(data, model_vsris))%>%
  mutate(mixedmodel_vsris_null = map(data, model_vsris_null))%>%
  mutate(mixedmodel_vsis = map(data, model_vsris))%>%
  mutate(mixedmodel_vsis_null = map(data, model_vsris_null))%>%
  mutate(mixedmodel_vscris = map(data, model_vscris))%>%
  mutate(mixedmodel_vscris_null = map(data, model_vscris))
```

Add model predictions. Using predict adds a prediction for each location, using broom::augment adds predictions (.mu) and residuals (.wtres).
```{r}
data.sc_r <- data.sc_r %>%
  mutate(fit = map(mixedmodel_vsris, predict))

data.sc_r <- data.sc_r %>%
  mutate(fits = map(mixedmodel_vsris, broom::augment))
```

Add model metrics. Not used to make the figures below, but useful.
```{r}
data.sc_r <- data.sc_r %>%
  mutate(glance = map(mixedmodel_vsris, broom::glance))
```

Add summaries of model output
```{r}
data.sc_r <- data.sc_r %>%
  mutate(tidy = map(mixedmodel_vsris, broom::tidy))
```

Extract coefficients for individual mice. The function is to convert the output of coef() to a dataframe so it will work with unnest.
```{r}
# coef_df is a helper function to return model coefficients in a tidy formt.
data.sc_r <- data.sc_r %>%
  mutate(coefs = map(mixedmodel_vsris, coef_df))
```


Convert data from the nested format so that we can make plots of the fitted data.
```{r}
data.sc_r_fit <- data.sc_r %>%
  unnest(data, fit)
```

Compare different model with null models.
```{r}
extract_coefs <- function(model){as.numeric(summary(model)$"coefficients"[[2]])}
extract_r2 <- function(model, index){as.numeric(r.squaredGLMM(model)[index])}
extract_slope <- function(model, index){as.numeric(summary(coef(model)[[1]][[2]])[index])}

mdl.comp <- function(a, b){
  anova(a, b)$"Pr(>Chisq)"[2]
}

# Store model gradient, marginal and conditional R2 and p-value vs null model.
data.sc_r <- data.sc_r %>%
  mutate(gradient_slopes = map(mixedmodel_vsris, extract_coefs)) %>%
  mutate(marginal.r2 = map2(mixedmodel_vsris, 1, ~extract_r2(.x,.y)))
data.sc_r <- data.sc_r %>%
  mutate(conditional.r2 = map2(mixedmodel_vsris, 2, ~extract_r2(.x,.y)))
data.sc_r <- data.sc_r %>%
  mutate(anova = map2(mixedmodel_vsris, mixedmodel_vsris_null, ~anova(.x,.y))) %>%
  mutate(tidy_anova = map(anova, broom::tidy)) %>% 
        mutate(anova_p_val = map_dbl(tidy_anova, ~.$p.value[2]))

# Store model slopes
data.sc_r <- data.sc_r %>%
  mutate(modelslope_min = (map2(mixedmodel_vsris, 1, ~extract_slope(.x,.y)))) %>%
  mutate(modelslope_median = (map2(mixedmodel_vsris, 3, ~extract_slope(.x,.y)))) %>%
  mutate(modelslope_max = (map2(mixedmodel_vsris, 5, ~extract_slope(.x,.y))))
  

#   # Store AIC for all models
#   results_model$AIC_vsris[i] <- summary(model_vsris)$"AIC"[1]
#   results_model$AIC_null[i] <- summary(model_null)$"AIC"[1]
#   results_model$AIC_vsri[i] <- summary(model_vsri)$"AIC"[1]
#   results_model$AIC_vscris[i] <- summary(model_vscris)$"AIC"[1]

```


Compare linear models with mixed models. Does adding random effects lead to a statistically different model? 

Test whether effects of animal id are significant compare mixed model fits with linear model fits. Modified from: https://web.stanford.edu/class/psych252/section/Mixed_models_tutorial.html.
```{r Compare mixed with linear model using chisq}
## linearmodel_to_fit fits: lm(value ~ dvlocmm, data = df, na.action = na.exclude)
data.sc_r <- data.sc_r %>%
  mutate(linearmodel = map(data, linearmodel_to_fit))

data.sc_r <- bind_cols(data.sc_r, mixed_vs_linear_pchisqu(data.sc_r))
```



Show model fitting results as a table.
```{r}
props_for_table <- c("property", "gradient_slopes", "modelslope_min", "modelslope_max", "anova_p_val", "marginal.r2", "conditional.r2", "pdiff")
props_table <- as.tibble(data.sc_r[props_for_table])
props_table_unnest <- unnest(props_table)

  knitr::kable(
  props_table_unnest,
  digits = 5,
  caption = "Fit of measured membrane properties as a function of location"
)

write_csv(props_table_unnest, "results_model_table.csv")
```





------------------------ Make plots ----------------------
```{r}
ggplot(data.sc_r_fit, aes(x = dvlocmm, y = value, colour = housing)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property, scales = "free")
```

Extract individual slopes and intercepts from model fits.
```{r}
data.sc_r_coefs <- data.sc_r %>%
  unnest(coefs)
```


Plot distributions of intercepts.
```{r}
labels_intercepts <- c(ahp = "AHP min. (mV)", fi = "F-I (Hz / pA)", ir = "IR (MΩ)", resf = "Res F (Hz)", resmag = "Res. mag.", rheo = "Rheobase (pA)", sag = "Sag", spkhlf = "Spike h-w (ms)", spkmax = "Spike max. (mV)", spkthr = "Spike thres. (mV)", tau = "Tm (ms)", vm = "Vrest (mV)")


intercept_histograms <- ggplot(data.sc_r_coefs, aes(intercept)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_intercepts)) +
  theme_classic() +
  hist_theme

intercept_histograms
```

Plot intercepts as violin plots. Could try using geom_blank here to set the scales.
```{r}
intercept_violins <- ggplot(data.sc_r_coefs, aes(x = property, y = intercept)) +
  geom_violin() +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) 
intercept_violins
```


Plot distributions of slopes.
```{r}
labels_slopes <- c(ahp = "AHP (mV / mm)", fi = "F-I (Hz / pA mm)", ir = "IR (MΩ / mm)", resf = "Res F (Hz / mm)", resmag = "Res mag (/ mm)", rheo = "Rheobase (pA / mm)", sag = "Sag (/ mm)", spkhlf = "Spike half-width (ms / mm)", spkmax = "Spike maximum (mV / mm)", spkthr = "Spike Threshold (mV / mm)", tau = "Tm (ms / mm)", vm = "Vrest (mV / mm)")

slope_histograms <- ggplot(data.sc_r_coefs, aes(slope)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_slopes)) +
  theme_classic() +
  hist_theme

slope_histograms
```

Plot slopes as violin plots.
```{r}
slope_violins <- ggplot(data.sc_r_coefs, aes(x = property, y = slope)) +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  )
slope_violins
```

Add slope to intercept to predict values at 1 mm for each mouse.
```{r}
data.sc_r_coefs$is <- data.sc_r_coefs$intercept + data.sc_r_coefs$slope
```

To enable plotting of slopes on the same graph, but seperately from the intercepts, make columns containing population intercepts, and population intercept + slope for each mouse.
```{r}
pop_intercepts <- unnest(data.sc_r, tidy) %>% filter(term == "(Intercept)") %>% dplyr::select(property, estimate)
data.sc_r_coefs_regather <- data.sc_r_coefs %>%
  dplyr::select(property, id, slope) %>%
  spread(key = id, value = slope) %>%
  left_join(pop_intercepts, by = "property") %>%
  gather("id", "slope", -estimate, -property) %>%
  mutate(intercept_slope = estimate + slope) %>%
  dplyr::select(property, id, estimate, intercept_slope) %>%
  gather(measure, value, estimate, intercept_slope)
```



Plot predicted values at 0 mm and at 1mm for each mouse.
```{r}
data.sc_r_coefs_01 <- data.sc_r_coefs %>%
  dplyr::select(id, property, intercept, is) %>%
  gather(measure, value, intercept, is)
intercept_slope_plot_a <- ggplot(data.sc_r_coefs_01, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_b <- ggplot(data.sc_r_coefs_01, aes(x = measure, y = value)) +
  geom_jitter(width = 0.2, height = 0) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_a
intercept_slope_plot_b
```

Make plots of slopes.
```{r}
slope_plot <- ggplot(data.sc_r_coefs_regather, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme

slope_plot
```

Combine plots of intercept and slopes. Need to combine data.sc_r_coefs_01 and data.sc_r_coefs_regather and add housing. Make property into factors to enable ordering of plots. Then make appropriately faceted plots.
```{r}
data.sc_r_coefs_regather <- mutate(data.sc_r_coefs_regather, value_1 = value)
data.sc_r_coefs_01 <- mutate(data.sc_r_coefs_01, value_2 = value)
combined_intercepts_slopes <- bind_rows(data.sc_r_coefs_regather, data.sc_r_coefs_01)

id_housing <-  distinct(data.sc, id, housing)
combined_intercepts_slopes <- left_join(combined_intercepts_slopes, id_housing, by = "id")

combined_intercepts_slopes$property_factors <- as.factor(combined_intercepts_slopes$property)
combined_intercepts_slopes$property_factors = factor(combined_intercepts_slopes$property_factors, c("vm", "ir", "sag", "tau", "resf", "resmag", "rheo", "fi", "ahp", "spkmax", "spkthr", "spkhlf"))

IS_figure <- ggplot(combined_intercepts_slopes, aes(x = measure, y = value_1, colour = housing)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("intercept", "is",  "estimate", "intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~property_factors, scales = "free",  labeller = labeller(property_factors = labels_intercepts)) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure
```

Save the figure.
```{r}
ggsave("I_S_figure.png", width = 140, height = 120, units = "mm")
```



Save the plots as vector graphics.
```{r}
svg(filename = "I_S_figure.png", width=6, height=4)
IS_figure
dev.off()
```

Look at relationships between the intercepts.
```{r}
combined_intercepts_slopes_si <- dplyr::select(data.sc_r_coefs, property, id, intercept)  %>%
  spread(property, intercept)
ggpairs(combined_intercepts_slopes_si,columns = c(2:13),
         lower = list(
          continuous = "points",
          mapping = aes(colour = id)
        ),
        ggplot2::aes(alpha = 0.1))
```

Look at relationships between the slopes
```{r}
combined_intercepts_slopes_ss <- dplyr::select(data.sc_r_coefs, property, id, slope)  %>%
  spread(property, slope)
ggpairs(combined_intercepts_slopes_ss,columns = c(2:13),
        lower = list(
          continuous = "points",
          mapping = aes(colour = id)
        ),
        ggplot2::aes(alpha = 0.1))
```



Now repeat with normalised data.

Normalise property measurements.
```{r}
normalize<-function(m){
   (m - min(m, na.rm = TRUE))/(max(m, na.rm = TRUE)-min(m, na.rm = TRUE))
}

data.sc.norm <- as.data.frame(lapply(data.sc[1:12], normalize))
data.sc.norm$dvlocmm <- data.sc$dvlocmm
data.sc.norm$id <- data.sc$id

```

Analysis is as above. Loop through the data.
1. Create a model for each measured parameter.
2. Store plots for fitted slopes for each mouse.
```{r}
# reformat data
data.sc.norm_r <- data.sc.norm %>%
  select(vm:fi, dvlocmm, id) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()

# apply lmer to all measurements
model_to_fit <- function(df) {
  lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(mixedmodel = map(data, model_to_fit))

# add predictions
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fit = map(mixedmodel, predict))
# or this? gives predictions as .mu.
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fits = map(mixedmodel, broom::augment))

# add model metrics
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(glance = map(mixedmodel, broom::glance))

# extract data
data.sc.norm_r_fit <- data.sc.norm_r %>%
  unnest(data, fit)

# make plots
ggplot(data.sc.norm_r_fit, aes(x = dvlocmm, y = value)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property)


```



