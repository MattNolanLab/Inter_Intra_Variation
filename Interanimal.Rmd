---
title: "Inter-animal variability"
author: "Matt Nolan"
date: "13/04/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Ensure access to libraries
library(lme4)
library(MuMIn)
library(tidyverse)
library(ggpubr)
library(corrplot)
library(modelr)
```

## Goals

To evaluate interanimal differences in properties of L2SCs.

Specific properties for filtering data. Include animals ≥ 28 days.
```{r}
min_age <- 0
```

Import the data, remove rows with unknown locations and summarise numbers of observations and animals. 
```{r import data, message = FALSE}
# fname.sc <- "/Users/hughpastoll/Research/stellateintrinsic/Database/datatable.txt"
fname.sc <- "/Users/mattnolan/Dropbox/Modules_data/stellateintrinsic/Database/datatable.txt"
data.import <- read_tsv(fname.sc)

# Strip out rows from data where locations are unknown (are NaN)
data.sc <- data.import %>% drop_na(dvloc)

# Convert dvloc from microns to millimetres - prevents errors in model fitting large dv values
data.sc <- mutate(data.sc, dvlocmm = dvloc/1000)

# Keep animals ≥ min_age
data.sc.old <- filter(data.sc, age >= min_age)

# Calculate total number of observations, and number in each environment
length(data.sc.old$housing)
count(data.sc.old, housing)

# Calculate number of observations per animal
counts.old <- data.sc.old %>% count(id)
summary(counts.old)
```

Reformat data for use with map and othe rtidy tidyverse functions.
```{r}
data.sc_r <- data.sc %>%
  select(vm:fi, dvlocmm, id) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()
```

Fit mixed models to all measured properties using lmer
```{r}
model_to_fit <- function(df) {
  lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
data.sc_r <- data.sc_r %>%
  mutate(mixedmodel = map(data, model_to_fit))
```

Add model predictions. Using predict adds a prediction for each location, using broom::augment adds predictions (.mu) and residuals (.wtres).
```{r}
data.sc_r <- data.sc_r %>%
  mutate(fit = map(mixedmodel, predict))

data.sc_r <- data.sc_r %>%
  mutate(fits = map(mixedmodel, broom::augment))
```

Add model metrics. Not used to make the figures below, but useful.
```{r}
data.sc_r <- data.sc_r %>%
  mutate(glance = map(mixedmodel, broom::glance))
```

Add summaries of model output
```{r}
data.sc_r <- data.sc_r %>%
  mutate(tidy = map(mixedmodel, broom::tidy))
```

Extract coefficients for individual mice. The function is to convert the output of coef() to a dataframe so it will work with unnest. Not sure how to do this and keep the mouse ids, but this is fine for the analyses we want to do.
```{r}
coef_df <- function(model_name) {
  mod_coef <- coef(model_name)
  #coef_df <- as.data.frame(coef(model_name)[[1]])
  tibble(intercept = mod_coef[[1]][[1]], slope = mod_coef[[1]][[2]])
}
data.sc_r <- data.sc_r %>%
  mutate(coefs = map(mixedmodel, coef_df))
```

Convert data from the nested format so that we can make plots of the fitted data.
```{r}
data.sc_r_fit <- data.sc_r %>%
  unnest(data, fit)
```

Make plots
```{r}
ggplot(data.sc_r_fit, aes(x = dvlocmm, y = value)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property, scales = "free")
```

Extract individual slopes and intercepts from model fits.
```{r}
data.sc_r_coefs <- data.sc_r %>%
  unnest(coefs)
```

Calculate intercept values with mean substracted so they can be compared to slopes.


Plot distributions of intercepts.
```{r}
ggplot(data.sc_r_coefs, aes(intercept)) +
  geom_histogram(bins = 20, colour = "blue") +
  geom_histogram(aes(slope), bins = 20, colour = "red") +
  facet_wrap(~property, scales = "free")
```

Plot intercepts as violin plots
```{r}
ggplot(data.sc_r_coefs, aes(x = property, y = intercept)) +
  geom_violin() +
  facet_wrap(~property, scales = "free")
```


Plot distributions of slopes.
```{r}
ggplot(data.sc_r_coefs, aes(slope)) +
  geom_density(adjust = 0.1) +
  facet_wrap(~property, scales = "free")
```

Plot slopes as violin plots.
```{r}
ggplot(data.sc_r_coefs, aes(x = property, y = slope)) +
  geom_violin(adjust = 1) +
  facet_wrap(~property, scales = "free")
```



Now repeat with normalised data.

Normalise property measurements.
```{r}
normalize<-function(m){
   (m - min(m, na.rm = TRUE))/(max(m, na.rm = TRUE)-min(m, na.rm = TRUE))
}

data.sc.norm <- as.data.frame(lapply(data.sc[1:12], normalize))
data.sc.norm$dvlocmm <- data.sc$dvlocmm
data.sc.norm$id <- data.sc$id

```

Analysis is as above. Loop through the data.
1. Create a model for each measured parameter.
2. Store plots for fitted slopes for each mouse.
```{r}
# reformat data
data.sc.norm_r <- data.sc.norm %>%
  select(vm:fi, dvlocmm, id) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()

# apply lmer to all measurements
model_to_fit <- function(df) {
  lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(mixedmodel = map(data, model_to_fit))

# add predictions
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fit = map(mixedmodel, predict))
# or this? gives predictions as .mu.
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fits = map(mixedmodel, broom::augment))

# add model metrics
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(glance = map(mixedmodel, broom::glance))

# extract data
data.sc.norm_r_fit <- data.sc.norm_r %>%
  unnest(data, fit)

# make plots
ggplot(data.sc.norm_r_fit, aes(x = dvlocmm, y = value)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property)


```



