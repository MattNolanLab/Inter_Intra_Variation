---
title: "Inter-animal variability"
author: "Matt Nolan"
date: "13/04/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Ensure access to libraries
library(lme4)
library(MuMIn)
library(tidyverse)
library(ggpubr)
library(modelr)
library(corrplot)
library(ggthemes)
library(broom)
library(skimr)
library(GGally)
library(MCMCglmm)
library(RColorBrewer)
library(glmnet)
```
Source functions

```{r}
source_rmd <- function(file, local = FALSE, ...){
  options(knitr.duplicate.label = 'allow')

  tempR <- tempfile(tmpdir = ".", fileext = ".R")
  on.exit(unlink(tempR))
  knitr::purl(file, output=tempR, quiet = TRUE)

  envir <- globalenv()
  source(tempR, local = envir, ...)
}
source_rmd("Functions.Rmd")
```

## Goals

To evaluate interanimal differences in properties of L2SCs.

Specific properties for filtering data. Include animals ≥ 28 days.
```{r}
min_age <- 0
```

Import the data, remove rows with unknown locations and summarise numbers of observations and animals. 
```{r import data, message = FALSE}

## fname.sc <- "/Users/hughpastoll/Research/stellateintrinsic/Database/datatable.txt"
start.dir <- "~/Dropbox/org/Research/Software/R/Modular_Intrinsic_Properties/"
fname.sc <- "datatable.txt"

data.import <- read_tsv(paste0(start.dir, fname.sc))

# Strip out rows from data where locations are unknown (are NaN)
data.sc <- data.import %>% drop_na(dvloc)

# Convert dvloc from microns to millimetres - prevents errors in model fitting large dv values
data.sc <- mutate(data.sc, dvlocmm = dvloc/1000)

# Keep animals ≥ min_age
data.sc.old <- filter(data.sc, age >= min_age)

# Calculate total number of observations, and number in each environment
length(data.sc.old$housing)
count(data.sc.old, housing)

# Calculate number of observations per animal
counts.old <- data.sc.old %>% count(id)
summary(counts.old)
```

Visualize all pairwise dependencies between measured properties
```{r}
## vizualise on a common N(0,1) scale
edf <- function(x) rank(x)/(1+length(x))

data.sc %>% dplyr::select(vm:fi) %>%
    apply(2, edf) %>% apply(2, qnorm) %>%
    pairs
## contrast with original scale
data.sc %>% dplyr::select(vm:fi) %>%
    pairs
```

Reformat data for use with map and other tidyverse functions.
```{r}
data.sc_r <- data.sc %>%
    dplyr::select(vm:fi, dvlocmm, id, housing) %>%
    gather("property", "value", vm:fi) %>%
    group_by(property) %>%
    nest()
```



Fit mixed models to all measured properties using lmer and MCMCglmm
```{r}
# model_to_fit moved to functions.
# lme4::lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
data.sc_r <- data.sc_r %>%
    mutate(mixedmodel_vsris              = map(data, model_vsris))      %>%
    mutate(mixedmodel_vsris_null         = map(data, model_vsris_null)) %>%
    mutate(mixedmodel_vsri               = map(data, model_vsri))       %>%
    mutate(mixedmodel_vsri_null          = map(data, model_vsri_null))  %>%
    mutate(mixedmodel_vscris             = map(data, model_vscris))     %>%
    mutate(mixedmodel_vscris_null        = map(data, model_vscris))     %>%
    mutate(mixedmodel_vsri_Bayes         = map(data, model_vsri_Bayes)) %>%
    mutate(mixedmodel_vsri_null_Bayes    = map(data, model_vsri_null_Bayes))  %>%
    mutate(mixedmodel_vsris_Bayes        = map(data, model_vsris_Bayes))      %>%
    mutate(mixedmodel_vsris_null_Bayes   = map(data, model_vsris_null_Bayes)) %>%
    mutate(mixedmodel_vsrisc_Bayes       = map(data, model_vsrisc_Bayes)) %>%
    mutate(mixedmodel_vsrisc_null_Bayes  = map(data, model_vsrisc_null_Bayes))

## data.sc_r <- data.sc_r %>% 
##     mutate(DIC_vsris_Bayes       = map_dbl(vsris_summary, ~.$AIC[[1]])) %>%
##     mutate(DIC_vsris_null_Bayes  = map_dbl(vsris_null_summary, ~.$AIC[[1]])) %>%
##     mutate(DIC_vsri_Bayes        = map_dbl(vsri_summary, ~.$AIC[[1]])) %>%
##     mutate(DIC_vcsris_Bayes      = map_dbl(vscris_summary, ~.$AIC[[1]]))
```    



Add model predictions. Using predict adds a prediction for each
location, using broom::augment adds predictions (.mu) and residuals
(.wtres).
```{r}
data.sc_r <- data.sc_r %>%
  mutate(fit = map(mixedmodel_vsris, predict))

data.sc_r <- data.sc_r %>%
  mutate(fits = map(mixedmodel_vsris, broom::augment))
```

Add model metrics (with glance) and summaries (with tidy). Not used to
make the figures below, but useful.
```{r}
data.sc_r <- data.sc_r %>%
  mutate(glance = map(mixedmodel_vsris, broom::glance)) %>%
  mutate(tidy = map(mixedmodel_vsris, broom::tidy))
```

Extract coefficients for individual mice. The function is to convert
the output of coef() to a dataframe so it will work with unnest.
```{r}
# coef_df is a helper function to return model coefficients in a tidy format.
data.sc_r <- data.sc_r %>%
  mutate(coefs = map(mixedmodel_vsris, coef_df))
```

Convert data from the nested format so that we can make plots of the
fitted data.
```{r}
data.sc_r_fit <- data.sc_r %>%
  unnest(data, fit)
```

Compare different model with null models.
```{r}
# Store model gradient (extracted with summary), marginal and conditional R2 (extracted with r.squaredGLMM) and p-value vs null model (calculated with ANOVA vs null model).
data.sc_r <- data.sc_r %>%
    mutate(vsris_summary = map(mixedmodel_vsris, summary)) %>%
    mutate(vsris_null_summary = map(mixedmodel_vsris_null, summary)) %>%
    mutate(vsri_summary = map(mixedmodel_vsri, summary)) %>%
    mutate(vscris_summary = map(mixedmodel_vscris, summary)) %>%
    mutate(gradient_slopes = map_dbl(vsris_summary, ~.$coefficients[[2]])) %>%
    mutate(extractR2 = map(mixedmodel_vsris, r.squaredGLMM)) %>%
    mutate(marginal.r2 = map_dbl(extractR2, ~.[[1]])) %>%
    mutate(conditional.r2 = map_dbl(extractR2, ~.[[2]])) %>%
    mutate(anova = map2(mixedmodel_vsris, mixedmodel_vsris_null, ~anova(.x,.y))) %>%
    mutate(tidy_anova = map(anova, broom::tidy)) %>% 
    mutate(anova_p_val = map_dbl(tidy_anova, ~.$p.value[2]))

                                        # Extract model slopes
data.sc_r <- data.sc_r %>%
    mutate(vsris_simcoefs    = map(mixedmodel_vsris, ~summary(coef(.x)[[1]][[2]]))) %>%
    mutate(modelslope_min    = map_dbl(vsris_simcoefs, ~.[[1]])) %>%
    mutate(modelslope_median = map_dbl(vsris_simcoefs, ~.[[3]])) %>%
    mutate(modelslope_max    = map_dbl(vsris_simcoefs, ~.[[6]]))


data.sc_r <- data.sc_r %>%
    mutate(vsris_simcoefs     = map(mixedmodel_vsris, ~summary(coef(.x)[[1]][[2]]))) %>%
    mutate(modelslope_min     = map_dbl(vsris_simcoefs, ~.[[1]])) %>%
    mutate(modelslope_median  = map_dbl(vsris_simcoefs, ~.[[3]])) %>%
    mutate(modelslope_max     = map_dbl(vsris_simcoefs, ~.[[6]]))

# Extract AIC and DIC for all models
data.sc_r <- data.sc_r %>% 
    mutate(AIC_vsris             = map_dbl(vsris_summary, ~.$AIC[[1]])) %>%
    mutate(AIC_vsris_null        = map_dbl(vsris_null_summary, ~.$AIC[[1]])) %>%
    mutate(AIC_vsri              = map_dbl(vsri_summary, ~.$AIC[[1]])) %>%
    mutate(AIC_vcsris            = map_dbl(vscris_summary, ~.$AIC[[1]])) %>%
    mutate(DIC_vsris_Bayes       = map(mixedmodel_vsris_Bayes, ~.$DIC)) %>%
    mutate(DIC_vsris_null_Bayes  = map(mixedmodel_vsris_null_Bayes, ~.$DIC)) %>%
    mutate(DIC_vsri_Bayes        = map(mixedmodel_vsri_Bayes, ~.$DIC)) %>%
    mutate(DIC_vsri_null_Bayes   = map(mixedmodel_vsri_null_Bayes, ~.$DIC)) %>%
    mutate(DIC_vsrisc_Bayes      = map(mixedmodel_vsrisc_Bayes, ~.$DIC)) %>%
    mutate(DIC_vsrisc_null_Bayes = map(mixedmodel_vsrisc_null_Bayes, ~.$DIC))


DICdat <- bind_rows(data.sc_r %>% dplyr::
                    select(property, contains("DIC"))) %>% as.data.frame 

DICdat_long           <-  gather(DICdat, model, value, -property)
DICdat_long$value     <-  unlist(DICdat_long$value)
DICdat_long$model     <-  factor(DICdat_long$model)
DICdat_long$property  <-  factor(DICdat_long$property)

ggplot(data=DICdat_long) +
    geom_line(aes(x=reorder(model,-value), y=value,group=property)) +
    facet_wrap(~property, scales="free") + ylab("DIC") +
    xlab("model") + theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
## TODO mutate an actual model name column: strip away DIC and 
## TODO move code to plots section

```


Obtain 95% high posterior density intervals
```{r}
data.sc_r <- data.sc_r %>%
    mutate(HPDsol_vsri_Bayes    = map(mixedmodel_vsri_Bayes, HPD,
                                      type="sol")) %>%
    mutate(HPDsol_vsris_Bayes   = map(mixedmodel_vsris_Bayes, HPD,
                                      type="sol")) %>%
    mutate(HPDsol_vsrisc_Bayes  = map(mixedmodel_vsrisc_Bayes, HPD,
                                      type="sol")) %>%
    mutate(HPDvcov_vsri_Bayes   = map(mixedmodel_vsri_Bayes, HPD,
                                      type="vcov")) %>%
    mutate(HPDvcov_vsris_Bayes  = map(mixedmodel_vsris_Bayes, HPD,
                                      type="vcov")) %>%
    mutate(HPDvcov_vsrisc_Bayes = map(mixedmodel_vsrisc_Bayes, HPD,
                                      type="vcov"))



data.sc_r <- data.sc_r %>%
    ## Random intercepts
    mutate(HPDri_vsri_Bayes=map(HPDsol_vsri_Bayes,
                                HPDforggplot,
                                stringmatch="Intercept).id.mouse",
                                stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))        %>%
    mutate(HPDri_vsris_Bayes=map(HPDsol_vsris_Bayes,
                                 HPDforggplot,
                                 stringmatch="Intercept).id.mouse",
                                 stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))      %>%
    mutate(HPDri_vsrisc_Bayes=map(HPDsol_vsrisc_Bayes,
                                  HPDforggplot,
                                  stringmatch="Intercept).id.mouse",
                                  stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))   %>%
    ## Random slopes
    mutate(HPDrs_vsris_Bayes=map(HPDsol_vsris_Bayes,
                                 HPDforggplot,
                                 stringmatch="dvlocmm.id.mouse",
                                 stringreplace="dvlocmm\\.id\\.mouse\\_"))      %>%
    mutate(HPDrs_vsrisc_Bayes=map(HPDsol_vsrisc_Bayes,
                                  HPDforggplot,
                                  stringmatch="dvlocmm.id.mouse",
                                  stringreplace="dvlocmm\\.id\\.mouse\\_")) %>%
    ## variance-covariance


## plot.intercepts

## tmp  <- gather(data.sc_r$HPDsol_vsri_Bayes[[1]],  HPDendpoint, value, -rname) 
## tmp2 <- tmp %>% dplyr::filter(grepl(rname, pattern="Intercept).id.mouse")) %>%
##     mutate(mouse.id=gsub(pattern="\\(Intercept\\)\\.id\\.", replacement="", tmp2$rname))

## tmp2%>%
##     ggplot(aes(x=reorder(mouse.id,value),
##                y=value, group=factor(HPDendpoint))) + geom_line() +
##     theme_classic() + xlab("Mouse") +
##     theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Obtain posterior mean of all coefficients
```{r}
data.sc_r <- data.sc_r%>%
    mutate(PMri_vsri_Bayes   = map(mixedmodel_vsri_Bayes, post_summary,
                                    type="sol", statistic=mean,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(PMri_vsris_Bayes  = map(mixedmodel_vsris_Bayes, post_summary,
                                    type="sol", statistic=mean,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(PMri_vsrisc_Bayes = map(mixedmodel_vsrisc_Bayes, post_summary,
                                    type="sol", statistic=mean,
                                    stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                    stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))  %>%
    mutate(PMrs_vsris_Bayes  = map(mixedmodel_vsris_Bayes, post_summary,
                                    type="sol", statistic=mean,
                                    stringmatch="dvlocmm\\.id\\.mouse.*",
                                    stringreplace="dvlocmm\\.id\\.mouse\\_"))          %>%
    mutate(PMrs_vsrisc_Bayes = map(mixedmodel_vsrisc_Bayes, post_summary,
                                    type="sol", statistic=mean,
                                    stringmatch="dvlocmm\\.id\\.mouse.*",
                                    stringreplace="dvlocmm\\.id\\.mouse\\_"))          %>%
    mutate(PMvcov_vsri_Bayes   = map(mixedmodel_vsri_Bayes, post_summary,
                                     type="vcov", statistic=mean,
                                     stringmatch=".*",
                                     stringreplace=""))                                %>%
    mutate(PMvcov_vsris_Bayes  = map(mixedmodel_vsris_Bayes, post_summary,
                                     type="vcov", statistic=mean,
                                     stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                     stringreplace="\\(Intercept\\)\\.id\\.mouse\\_")) %>%
    mutate(PMvcov_vsrisc_Bayes = map(mixedmodel_vsrisc_Bayes, post_summary,
                                     type="vcov", statistic=mean,
                                     stringmatch="\\(Intercept\\)\\.id\\.mouse.*",
                                     stringreplace="\\(Intercept\\)\\.id\\.mouse\\_"))
```        


Obtain effective sample sizes from McMC output
```{r}

```




Compare linear models with mixed models. Does adding random effects lead to a statistically different model? 

Test whether effects of animal id are significant compare mixed model fits with linear model fits. Modified from: https://web.stanford.edu/class/psych252/section/Mixed_models_tutorial.html.
```{r Compare mixed with linear model using chisq}
## linearmodel_to_fit fits: lm(value ~ dvlocmm, data = df, na.action = na.exclude)
data.sc_r <- data.sc_r %>%
  mutate(linearmodel = map(data, linearmodel_to_fit))

data.sc_r <- bind_cols(data.sc_r, mixed_vs_linear_pchisqu(data.sc_r))
```



Show model fitting results as a table.
```{r}
props_for_table <- c("property", "gradient_slopes", "modelslope_min",
                     "modelslope_max", "anova_p_val", "marginal.r2",
                     "conditional.r2", "pdiff") ## !!! review modelslope_max
props_table <- as.tibble(data.sc_r[props_for_table])
props_table_unnest <- unnest(props_table)

  knitr::kable(
  props_table_unnest,
  digits = 5,
  caption = "Fit of measured membrane properties as a function of location"
)

write_csv(props_table_unnest, "results_model_table.csv")
```





------------------------ Make plots ----------------------
```{r}
ggplot(data.sc_r_fit, aes(x = dvlocmm, y = value, colour = housing)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property, scales = "free")
```

Extract individual slopes and intercepts from model fits.
```{r}
data.sc_r_coefs <- data.sc_r %>%
  unnest(coefs)
```


Plot distributions of intercepts.
```{r}
labels_intercepts <- c(ahp = "AHP min. (mV)", fi = "F-I (Hz / pA)", ir = "IR (MΩ)", resf = "Res F (Hz)", resmag = "Res. mag.", rheo = "Rheobase (pA)", sag = "Sag", spkhlf = "Spike h-w (ms)", spkmax = "Spike max. (mV)", spkthr = "Spike thres. (mV)", tau = "Tm (ms)", vm = "Vrest (mV)")


intercept_histograms <- ggplot(data.sc_r_coefs, aes(intercept)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_intercepts)) +
  theme_classic() +
  hist_theme

intercept_histograms
```

Plot intercepts as violin plots. Could try using geom_blank here to set the scales.
```{r}
intercept_violins <- ggplot(data.sc_r_coefs, aes(x = property, y = intercept)) +
  geom_violin() +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) 
intercept_violins
```


Plot distributions of slopes.
```{r}
labels_slopes <- c(ahp = "AHP (mV / mm)", fi = "F-I (Hz / pA mm)", ir = "IR (MΩ / mm)", resf = "Res F (Hz / mm)", resmag = "Res mag (/ mm)", rheo = "Rheobase (pA / mm)", sag = "Sag (/ mm)", spkhlf = "Spike half-width (ms / mm)", spkmax = "Spike maximum (mV / mm)", spkthr = "Spike Threshold (mV / mm)", tau = "Tm (ms / mm)", vm = "Vrest (mV / mm)")

slope_histograms <- ggplot(data.sc_r_coefs, aes(slope)) +
  geom_histogram(bins = 20) +
  facet_wrap(~property, scales = "free",  labeller = labeller(property = labels_slopes)) +
  theme_classic() +
  hist_theme

slope_histograms
```

Plot slopes as violin plots.
```{r}
slope_violins <- ggplot(data.sc_r_coefs, aes(x = property, y = slope)) +
  geom_jitter(height = 0, width = 0.2) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  )
slope_violins
```

Add slope to intercept to predict values at 1 mm for each mouse.
```{r}
data.sc_r_coefs$is <- data.sc_r_coefs$intercept + data.sc_r_coefs$slope
```

To enable plotting of slopes on the same graph, but seperately from the intercepts, make columns containing population intercepts, and population intercept + slope for each mouse.
```{r}
pop_intercepts <- unnest(data.sc_r, tidy) %>% filter(term == "(Intercept)") %>% dplyr::select(property, estimate)
data.sc_r_coefs_regather <- data.sc_r_coefs %>%
  dplyr::select(property, id, slope) %>%
  spread(key = id, value = slope) %>%
  left_join(pop_intercepts, by = "property") %>%
  gather("id", "slope", -estimate, -property) %>%
  mutate(intercept_slope = estimate + slope) %>%
  dplyr::select(property, id, estimate, intercept_slope) %>%
  gather(measure, value, estimate, intercept_slope)
```



Plot predicted values at 0 mm and at 1mm for each mouse.
```{r}
data.sc_r_coefs_01 <- data.sc_r_coefs %>%
  dplyr::select(id, property, intercept, is) %>%
  gather(measure, value, intercept, is)
intercept_slope_plot_a <- ggplot(data.sc_r_coefs_01, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_b <- ggplot(data.sc_r_coefs_01, aes(x = measure, y = value)) +
  geom_jitter(width = 0.2, height = 0) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme
intercept_slope_plot_a
intercept_slope_plot_b
```

Make plots of slopes.
```{r}
slope_plot <- ggplot(data.sc_r_coefs_regather, aes(x = measure, y = value)) +
  geom_line(aes(group = id)) +
  facet_wrap(~property, scales = "free") +
  theme_classic() +
  hist_theme

slope_plot
```

Combine plots of intercept and slopes. Need to combine data.sc_r_coefs_01 and data.sc_r_coefs_regather and add housing. Make property into factors to enable ordering of plots. Then make appropriately faceted plots.
```{r}
data.sc_r_coefs_regather <- mutate(data.sc_r_coefs_regather, value_1 = value)
data.sc_r_coefs_01 <- mutate(data.sc_r_coefs_01, value_2 = value)
combined_intercepts_slopes <- bind_rows(data.sc_r_coefs_regather, data.sc_r_coefs_01)

id_housing <-  distinct(data.sc, id, housing)
combined_intercepts_slopes <- left_join(combined_intercepts_slopes, id_housing, by = "id")

combined_intercepts_slopes$property_factors <- as.factor(combined_intercepts_slopes$property)
combined_intercepts_slopes$property_factors = factor(combined_intercepts_slopes$property_factors, c("vm", "ir", "sag", "tau", "resf", "resmag", "rheo", "fi", "ahp", "spkmax", "spkthr", "spkhlf"))

IS_figure <- ggplot(combined_intercepts_slopes, aes(x = measure, y = value_1, colour = housing)) +
  geom_line(aes(group = id)) +
  geom_jitter(aes(y = value_2), width = 0.2) +
  scale_x_discrete(limits = c("intercept", "is",  "estimate", "intercept_slope"), label = c("I", "I + S", "", "")) +
  facet_wrap(~property_factors, scales = "free",  labeller = labeller(property_factors = labels_intercepts)) +
  theme_classic() +
  hist_theme +
  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank())

IS_figure
```

Save the figure.
```{r}
ggsave("I_S_figure.png", width = 140, height = 120, units = "mm")
```



Save the plots as vector graphics.
```{r}
svg(filename = "I_S_figure.png", width=6, height=4)
IS_figure
dev.off()
```

Look at relationships between the intercepts.
```{r}
combined_intercepts_slopes_si <- dplyr::select(data.sc_r_coefs, property, id, intercept)  %>%
  spread(property, intercept)
ggpairs(combined_intercepts_slopes_si,columns = c(2:13),
         lower = list(
          continuous = "points",
          mapping = aes(colour = id)
        ),
        ggplot2::aes(alpha = 0.1))
```

Look at relationships between the slopes
```{r}
combined_intercepts_slopes_ss <- dplyr::select(data.sc_r_coefs, property, id, slope)  %>%
  spread(property, slope)
ggpairs(combined_intercepts_slopes_ss,columns = c(2:13),
        lower = list(
          continuous = "points",
          mapping = aes(colour = id)
        ),
        ggplot2::aes(alpha = 0.1))
```



Now repeat with normalised data.

Normalise property measurements.
```{r}
normalize<-function(m){
   (m - min(m, na.rm = TRUE))/(max(m, na.rm = TRUE)-min(m, na.rm = TRUE))
}

data.sc.norm <- as.data.frame(lapply(data.sc[1:12], normalize))
data.sc.norm$dvlocmm <- data.sc$dvlocmm
data.sc.norm$id <- data.sc$id

```

Analysis is as above. Loop through the data.
1. Create a model for each measured parameter.
2. Store plots for fitted slopes for each mouse.
```{r}
# reformat data
data.sc.norm_r <- data.sc.norm %>%
  select(vm:fi, dvlocmm, id) %>%
  gather("property", "value", vm:fi) %>%
  group_by(property) %>%
  nest()

# apply lmer to all measurements
model_to_fit <- function(df) {
  lmer(value ~ dvlocmm +(1+dvlocmm||id), data = df, REML = FALSE, na.action = na.exclude)
}
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(mixedmodel = map(data, model_to_fit))

# add predictions
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fit = map(mixedmodel, predict))
# or this? gives predictions as .mu.
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(fits = map(mixedmodel, broom::augment))

# add model metrics
data.sc.norm_r <- data.sc.norm_r %>%
  mutate(glance = map(mixedmodel, broom::glance))

# extract data
data.sc.norm_r_fit <- data.sc.norm_r %>%
  unnest(data, fit)

# make plots
ggplot(data.sc.norm_r_fit, aes(x = dvlocmm, y = value)) +
  geom_point(alpha = 0.05) +
  geom_line(aes(y=fit, group = id), size=0.8, alpha = 0.5) +
  facet_wrap(~property)


```
