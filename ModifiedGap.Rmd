---
title: "ModifiedGapStatistic"
author: "Matt Nolan"
date: "28/02/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Modified gap statistic

Goal is to reimplement matlab code written by Hugh.

Start with an example dataset.
```{r}
test_data <- filter(data.sc, id == "mouse_20130416") %>%
  select(dvlocmm, ir)
colnames(test_data)[2] <- "value"

ggplot(test_data, aes(dvlocmm, value)) +
  geom_point()

K.max <- 6

# Partioning around mediods. Slower but more robust than k-means.
#pam1 = function(x, k){list(cluster = cluster::pam(x,k, cluster.only=TRUE))}
#clu_test <- cluster::clusGap(test_data, pam1, K.max = 6)
# K means.
clu_test <- cluster::clusGap(as.matrix(test_data$value), kmeans, K.max = 6, B = 50, nstart = 25)
clu_test <- as_tibble(clu_test[[1]])

clu_test$clus_num <- c(1:K.max)
clu_test <- mutate(clu_test,
         gap_min = gap - SE.sim,
         gap_max = gap + SE.sim)

ggplot(clu_test, aes(clus_num, gap)) +
  geom_point() +
  geom_errorbar(aes(ymin = gap_min, ymax = gap_max))

clu_diff = tibble(clus_num = c(1:(K.max-1)), gap_diff = diff(clu_test$gap))

# factoextra package also uses cluster::clusGap. Used to check for anything odd.
#factoextra::fviz_nbclust(as.matrix(test_data$value), kmeans, nstart = 25,  method = "gap_stat", nboot = 50) + labs(subtitle = "Gap statistic method")

```

Functions to generate gap statistics for simulated uniform distributions.
```{r, message=FALSE}
# Function to apply clusGap to each column in sim_data 
clusFunc <- function(df) {
  mat <- as.matrix(df)
  out <- cluster::clusGap(mat, kmeans, K.max = 6, B = 50, nstart = 25, verbose = FALSE)
  as_tibble(out$Tab)
}

# Function to generate gap values for data simulated from a uniform distribution
gap_uniform_sim <- function(n_cells = 20, K.max = 6, n_sim = 20, val_min = 0, val_max = 1){
  
  sim_data <- matrix(rep(runif(n_cells, value_min, value_max), n_sim), nrow = n_cells, ncol = n_sim)
  sim_gaps <- matrix(nrow = n_sim, ncol = K.max)
  
  sim_tib <- tibble(sim_num = c(1:n_sim), num_cells = n_cells, v_min = value_min, v_max = value_max)
  
# Make random numbers for each simulation, then calculate gap statistics for each set of random numbers, then calculate dela gap values.
  sim_tib <- mutate(sim_tib,
                  data = pmap(list(num_cells, v_min, v_max), runif),
                  gap_stats = map(data, clusFunc),
                  gaps = map(gap_stats, ~.$gap),
                  gap_delta = map(gaps, diff))
}
```


Calculate percentile cut offs.
Extract delta gap values into a matrix with columns for each k. Then calculate cut offs.
df should be a frame containing delta gap outputs, e.g. sim_tib$gap_delta
```{r}
calc_cutoffs <- function(df, cut_off = 0.9){
  n_sim = length(df)
  n_col = length(df[[1]])
  
  delta_gap_mat <- matrix(nrow = n_sim, ncol = n_col)
  for (i in 1:n_col) {
  delta_gap_mat[, i] <- sapply(df, function(x)
  x[[i]])
  }
  
  cut_off_vals <- vector(length = n_col)
  for (i in 1:n_col) {
  cut_off_vals[i] <- quantile(delta_gap_mat[, i], probs = (cut_off))
  }
  
  cut_off_vals

}


```

Generate gap statistics for simulated uniform distributions.
```{r}
# Parameters
n_sim <- 20
n_cells <- length(test_data$value)
value_min <- min(test_data$value)
value_max <- max(test_data$value)
value_min <- 0
value_max <- 1

# Generate simulated gap data
sim_tib <- gap_uniform_sim(n_cells, K.max, n_sim, val_min, val_max)
# Return cut off values from the data
cut_off_vals <- calc_cutoffs(sim_tib$gap_delta)
```


Compare real data with simulated data.
```{r}
clu_diff$gap_thresh <- cut_off_vals

ggplot(clu_diff) +
  geom_point(aes(clus_num, gap_diff), colour = "red") +
  geom_point(aes(clus_num, gap_thresh), colour = "blue")

```


Function to carry out modified gap aanlysis for a given property in a given animal. Returns gap and delta_gap values as well. Plots can be generated separately from the outputs.
```{r}
id <- "mouse_20130416"
property <- "ir"

# Wrapper to calculate gap statistic from data ausing K means and return results as a tibble.
clusGap_wrap <- function(df, K_max = 6){
  clu_test <- cluster::clusGap(as.matrix(df), kmeans, K.max = K_max, B = 50, nstart = 25)
  clu_test <- as_tibble(clu_test[[1]])
  clu_test$clus_num <- c(1:K.max)
  clu_test <- mutate(clu_test,
         gap_min = gap - SE.sim,
         gap_max = gap + SE.sim)
}


gap_analysis <- function(df = data.sc, name = "mouse_20130416", property = "ir", K_max = 6) {
  prop_data <- filter(df, id == name) %>%
  select(property)
  
  # Calculate gap statistic from the data ausing K means.
  clu_gap <- clusGap_wrap(prop_data, K_max)

  # Calculate delta gap values from the data.
  out_frame <- tibble(gap = list(clu_gap), diff_gap = list(diff(clu_gap$gap)))
  
  # Check if delta gap threshold values from shuffled data have been calculated for the n used. If yes then load them, if not then calculate and save them.
  
}
```



